[
  {
    "objectID": "posts/how_to_install_python_package_under_offline_enviromnent/index.html",
    "href": "posts/how_to_install_python_package_under_offline_enviromnent/index.html",
    "title": "오프라인에서 패키지 설치하기",
    "section": "",
    "text": "인터넷이 연될되지 않은 상황에서 파이썬 패키지를 설치하고자 할 때 알아두어야 할 것을 정리해 보고자 한다."
  },
  {
    "objectID": "posts/how_to_install_python_package_under_offline_enviromnent/index.html#패키지를-받기",
    "href": "posts/how_to_install_python_package_under_offline_enviromnent/index.html#패키지를-받기",
    "title": "오프라인에서 패키지 설치하기",
    "section": "패키지를 받기",
    "text": "패키지를 받기\npypi에서 whl 하나를 받을 순 있긴 한데 관련된 패키지가 없으면 결국 작동이 안된다. pip download {{패키지 이름}} 형식으로 작성하면 된다.\n단 운영하고자 하는 OS에서 가동이 가능한 파일을 받아야 한다."
  },
  {
    "objectID": "posts/how_to_install_python_package_under_offline_enviromnent/index.html#패키지-파일을-옮기기",
    "href": "posts/how_to_install_python_package_under_offline_enviromnent/index.html#패키지-파일을-옮기기",
    "title": "오프라인에서 패키지 설치하기",
    "section": "패키지 파일을 옮기기",
    "text": "패키지 파일을 옮기기\n패키지 파일을 설치하고자 하는 컴퓨터로 옮겨야 한다. 이 부분은 망분리 방식에 따라 다르기 때문에 별도로 다루진 않는다."
  },
  {
    "objectID": "posts/how_to_install_python_package_under_offline_enviromnent/index.html#설치하기",
    "href": "posts/how_to_install_python_package_under_offline_enviromnent/index.html#설치하기",
    "title": "오프라인에서 패키지 설치하기",
    "section": "설치하기",
    "text": "설치하기\npip에서 링크 옵션을 지정해서 할 수 있다.\n–no-index옵션과 –find-links옵션을 쓰면 설치할 수 있다.\n패키지 중에서 API wrapper형식으로 된 경우 해당 소프트웨어를 설치해야 한다. altair를 쓰고자 하면 vega를 설치해야 한다.\n예시\npip install --no-index --find-links {패키지가 있는 경로} {설치할 패키지}"
  },
  {
    "objectID": "posts/bayesian_approach_for_COVID-19_vaccine_efficacy/index.html",
    "href": "posts/bayesian_approach_for_COVID-19_vaccine_efficacy/index.html",
    "title": "COVID-19 백신 효과 측정을 위한 베이지안 접근",
    "section": "",
    "text": "towardsdatascience의 한 포스트를 보았습니다. 베이지안 모델링을 백신 모델링에 사용한 글인데 이 글을 보고 백신의 효능을 측정하는데 있어 어떻게 통계 모델을 구성 하게 되는지 따라해 보면서 간단하게 정리해 보고자 합니다.\n\n\n뉴스에서 나오는 백신의 예방효과를 보통 퍼센트로 나타내곤 합니다. 화이자 백신은 95%이고, 아스트라제네카는 70%대의 예방률이 나온다고 하는 등 퍼센트로 예방효과를 설명하고 있는데요. 이 숫자들의 의미는 무엇일까요?\n단순하게 생각해 보면 화이자 백신을 맞으면 95% 확률로 코로나에 걸리지 않는 것으로 해석하기 쉬운데요. 대략적으로는 맞다고 할 수 있지만 엄밀하게 보면 틀린 해석입니다.\n좀 더 정확한 표현은 백신을 맞지 않은 사람보다 백신 맞은 사람이 코로나에 걸릴 확률이 95% 적다는 뜻입니다. 분모에 들어가는 기준이 되는 값이 백신을 맞지 않은 사람이 코로나에 걸릴 확률 인 것입니다. 즉 백신을 맞지 않은 사람 대비 백신을 맞은 사람의 코로나에 걸릴 확률이 백신의 예방효과에서 말하는 퍼센트의 의미입니다.\n수식으로 정리를 해보자면 아래와 같습니다.\n\\[\\text{Vaccine efficacy} = 100 \\cdot (1 - IRR)\\] \\[IRR = \\frac{\\text{vaccine incidence rate}}{\\text{placebo incidence rate}}\\]\nIRR(Incidence Rate Ratio)는 백신 접종자와 미접종자 간 코로나에 감염된 확률의 비율입니다.\n따라서 95% 비율로 코로나 감여 확률이 줄어 들었다고 이야기는 백신을 맞은 사람들은 맞지 않은 사람들보다 95% 코로나에 덜 걸렸다는 뜻입니다.\n일반적으로 신약을 출시할 때 글로벌 스탠다드는 무작위 대조 실험(RCT)를 진행해야 합니다. 일반적으로는 논문이 출간 된 다음에야 결과를 알 수 있는데, 2020년 당시에는 뉴스에서 간단하게 결과가 공개되어 확인할 수 있었습니다."
  },
  {
    "objectID": "posts/bayesian_approach_for_COVID-19_vaccine_efficacy/index.html#the-data",
    "href": "posts/bayesian_approach_for_COVID-19_vaccine_efficacy/index.html#the-data",
    "title": "COVID-19 백신 효과 측정을 위한 베이지안 접근",
    "section": "The Data",
    "text": "The Data\n기사에서 발표된 내용은 아래와 같이 간단하게 정리할 수 있습니다.\n\n화이자(Pfizer): 43,000 참가 2회분 접종(백신 또는 위약). 통제집단과 실험 집단의 크기는 동일 An efficacy of 95%는 among 170 확진자 중 8명이 백신 접종을 한 집단에서 나왔음을 의미\n모더나(Moderna): 30,000명 대상으로 실험 진행. 절반은 2회 백신 접종, 나머지 절반은 2회 위약 접종을 하였으며 95명의 확진자 중 90명이 위약 그룹에서 발생\n아스트라제네카 1번 요법(AstraZeneca regimen 1): 첫번째 요법(0.5회분 접종 후 한달 뒤 1회분 접종)을 맞은 2741명이 90% efficacy를 보였다고 한다는 건 확진자 37명 중 3명은 접종 그룹임을 의미.(실험군과 대조군의 크기가 같다고 가정)\n아스트라제네카 2번 요법(AstraZeneca regimen 2): 두번째 요법(한 달 간격으로 1회분씩 접종)을 실시한 8896참가자에게서 62% efficacy를 달성했다는 건 94명의 확진자 중, 26명이 백신 그룹에서 나왔음을 의미.(실험군과 대조군의 크기가 같다고 가정)"
  },
  {
    "objectID": "posts/bayesian_approach_for_COVID-19_vaccine_efficacy/index.html#베이지안-모델",
    "href": "posts/bayesian_approach_for_COVID-19_vaccine_efficacy/index.html#베이지안-모델",
    "title": "COVID-19 백신 효과 측정을 위한 베이지안 접근",
    "section": "베이지안 모델",
    "text": "베이지안 모델\n아주 간단한 모델을 만들어서 백신의 효능을 추정해 보려고 합니다.(실제 논문에서 다뤄지는 모델은 이보다 훨씬 복잡하긴 할 것입니다. 다만, 그 원리나 방법은 큰 차이는 없습니다.)\n우리가 구하고 싶은 백식의 효능을 구하기 위해서 먼저 데이터에서 두집단의 코로나에 걸릴 상대위험을 계산하고자 합니다.\n이런 계산을 밑바닥부터 계산할 수도 있겠지만, 이미 개발 된 오픈소스 패키지를 사용하고자 하며, 그 중에서 파이썬에서 많이 사용되는 pymc3를 활용해서 베이지안 모델을 만들어 보고자 합니다.\n베이지안 모델을 만들기 위해서는 일단 파라미터화 부터 시작해야 합니다. 모델을 어떻게 만들지 수식에 사용되는 각 항을 파라미터로 만들어서 컴퓨터를 통해 계산할 수 있도록 모델을 작성하고자 합니다.\n\n베이즈 정리를 통한 수식 전개\n그러기 위해서 먼저 수식을 베이즈 정리를 사용해서 전개해보고자 합니다.\n\\[  \n\\begin{align}\n\\text{Efficacy} &= 1 - \\frac{P(positive|treatment)}{P(positive|control)} \\\\\n              &= 1 - \\frac{ P(treatment|positive) \\cdot P(positive) / P(treatment) } {P(control|positive) \\cdot P(positive) / P(control)} \\\\\n              &= 1 - \\frac{P(treatment|positive) }{P(control|positive) } \\cdot \\frac{P(control)} {P(treatment)}\n\\end{align}\n\\]\n\n\\(P(positive|treatment)\\): 백신을 맞은(treatment) 사람이 양성일 확률\n\\(P(positive|control)\\): 백신을 맞지 않은(control) 사람이 양성일 확률\n\\(P(treatment|positive)\\): 양성인 사람이 백신을 맞았을 확률\n\\(P(control|positive)\\): 양성인 사람이 백신을 맞지 않았을 확률\n\\(P(control)\\): 어떤 사람이 백신을 맞지 않았을 확률\n\\(P(treatment)\\): 어떤 사람이 백신을 맞았을 확률\n\\(P(positive)\\): 양성일 확률\n\n이렇게 수식을 변경하는 이유는 베이즈 정리를 통해서 직접 측정할 수 없는 것(백신을 맞은 사람이 코로나에 걸릴 확률)을 측정할 수 있는 것(코로나에 걸린 사람이 백신에 맞았을 확률)로 바꿀 수 있기 때문입니다. 즉, 양성이 사람들이 어느 그룹에 속하는지만 알게 되면 우리는 백신의 효능을 측정할 수 있게 수식을 전개 할 수 있는 것입니다.\n\\(P(treatment|positive) = 1- p(control|positive)\\)임을 이용하면 우리는 단순히 \\(P(treatment|positive)\\)의 분포만을 확인하면 되는 것이고 이는 양성 환자의 수만이 의미가 있다고 볼 수 있습니다.\n\n\n데이터와 연결하기\n이렇게 모델(수식)을 만들고 나서는 데이터와 연결을 시켜야 합니다.\nlikelihood(우도)를 계산한다고 하는데 양성일 확률이 p로 주어졌을 때 주어진 데이터의 결과가 나올 확률을 구하는 것입니다.\npymc3에서는 observed 라는 키워드를 통해서 이를 구현할 수 있습니다.\n우선 필요한 패키지를 불러와서 설정을 합니다. pymc3는 모델링, matplotlib과 arivz는 시각화를 위해 필요하며 numpy는 데이터를 생성하기 위해 사용했습니다.\n\nimport numpy as np\nimport pymc3 as pm\nimport arviz as az\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nplt.style.use(\"fivethirtyeight\")\n\nimport warnings\n\nwarnings.filterwarnings(\"ignore\")\n\n우선 기사에서 나온 정보를 컴퓨터가 이해하기 좋은 형태로 가공했는데요. 즉 170명 중 8명이 백신 그룹에서 나온 사실을 이용해서 8개의 1과 162개의 0로 이루어진 array(배열)을 만들었습니다.\n\nn = 170\nn_treat = 8\nn_control = n - n_treat\ntreatment_data = np.concatenate([np.ones(n_treat), np.zeros(n_control)])\n\n\n\n모델링: 양성 환자가 백신을 맞은 그룹에 속한 확률 p\n양성 환자가 백신을 맞은 그룹에 속할 확률을 p라고 하자. 그렇게 p를 정했다고 가정하면 우리는 그 p값 하에서 우리가 가진 양성환자 데이터가 나올 확률(likelihood)를 계산할 수 있습니다. 백신에 대해서는 아는 것이 없기도 하고 모든 값이 가능하다고 생각하기 때문에 0과 1사이에 편향이 없는(uniform) 분포와 동일한 Beta(1, 1) 분포를 사전분포(prior distribution)으로 가정했습니다.\n\nwith pm.Model() as model:\n    rate = pm.Beta(\"P(treatment | positive)\", alpha=1, beta=1)  # p의 분포\n    likelihood = pm.Bernoulli(\"likelihood\", p=rate, observed=treatment_data) # p^8*(1-p)^162\n    efficacy = pm.Deterministic(\"vaccine efficacy\", 1-rate/(1-rate))\n\npm.model_to_graphviz(model)\n\n\n\n\n위 그래프를 조금 해석해 보려고 합니다.\n\\(P(treatment | positive)\\)는 양성일 때 treatment 그룹에 속할 확률입니다. likelihood가 회색인 이유는 \\(P(treatment | positive)\\)의 값이 정해졌을 때 데이터가 확인될 확률을 베르누이 분포로 구한 것이기 때문입니다.\n즉 아래 수식의 값을 구하는 것입니다. 여기서는 170명 중 8명이 백신 맞은 집단이기 때문에 아래와 같은 수식이 되는데요. p는 위에서 언급한 \\(P(treatment | positive)\\)와 같습니다. \\[likelihood = p^{8}(1-p)^{162} \\]\n이렇게 0과 1사이에 있는 p의 분포를 구할 수 있게 됩니다. 사전분포(Prior distribution)과 우도(likelihood)를 구할 수 있으면 우리는 베이즈 정리를 통해 사후분포(posterior distribution)를 얻을 수 잇게 됩니다. 그 p의 사후분포를 통해서 efficacy를 구하게 되는 것입니다.\n이제 이를 계산하는 여러가지 방법이 있겠지만, 계산의 현실성 문제 등으로 인해서 MCMC(Markov Chain Monte Carlo) 방법으로 계산을 해보겠습니다.\n사후분포를 구하기 위해서는 아래와 같은 코드를 실행 시키면 됩니다.\n\nwith model:\n    trace = pm.sample(\n        draws=5000, # sample 5000개를 뽑는다.\n        step=pm.HamiltonianMC(), # MCMC의 알고리즘중 HMC방식으로 진행\n        start=pm.find_MAP(),  # maximum posterior에서 시작\n        progressbar=True)\n\n\n\n\n\n\n    \n      \n      100.00% [9/9 00:00&lt;00:00 logp = -117.84, ||grad|| = 77]\n    \n    \n\n\nMultiprocess sampling (2 chains in 2 jobs)\n\n\nHamiltonianMC: [P(treatment | positive)]\n\n\n\n\n\n\n\n\n\n\n    \n      \n      100.00% [12000/12000 00:03&lt;00:00 Sampling 2 chains, 0 divergences]\n    \n    \n\n\nSampling 2 chains for 1_000 tune and 5_000 draw iterations (2_000 + 10_000 draws total) took 3 seconds.\n\n\n이렇게 구해진 p의 사후분포(기존의 지식에서 데이터를 포함해서 구한 분포)를 시각화 하면 아래와 같이 나온다.\n\nwith model:\n    az.plot_trace(trace)\n    pm.plot_posterior(trace, var_names=[\"vaccine efficacy\"])\nplt.show()\n\n\n\n\n\n\n\n위와 같이 0.91~0.98 사이에 있을 확률이 94%가 되고 평균은 0.94임으로 약 95%로 볼 수 있습니다.\n이렇게 뉴스에서 말하는 95% 예방 효과는 사실 91%에서 98% 사이에 대부분 속한다는 의미에 가깝습니다.\n\n\n4개의 회사의 발표된 내용을 사용해보자\n4개의 회사의 자료를 작업해야 하는데 똑같은 행위를 반복하기 때문에 함수를 만들어 계산해 보았습니다.\n\ndef get_efficacy_model(\n    treatment_data, \n    rate_name=\"P(treatment | positive)\", \n    likelihood_name=\"likelihood\", \n    efficacy_name=\"vaccine efficacy\",\n    alpha=1,\n    beta=1,\n    n_placebo=1,\n    n_vaccine=1,\n    model=pm.Model()\n    ):\n    with model:\n        rate = pm.Beta(rate_name, alpha=alpha, beta=beta)\n        likelihood = pm.Bernoulli(likelihood_name, p=rate, observed=treatment_data)\n        efficacy = pm.Deterministic(efficacy_name, 1-rate/(1-rate)*n_placebo/n_vaccine)\n    return model\n\ndef get_efficacy_model_with_name(treatment_data, name, alpha=1, beta=1, n_placebo=1, n_vaccine=1, model=model):\n    rate_name=f\"P({name} treatment | positive)\"\n    likelihood_name=f\"{name} likelihood\"\n    efficacy_name=f\"{name} vaccine efficacy\"\n    return get_efficacy_model(\n        treatment_data, \n        rate_name=rate_name, \n        likelihood_name=likelihood_name,\n        efficacy_name=efficacy_name,\n        alpha=alpha,\n        beta=beta,\n        n_placebo=n_placebo,\n        n_vaccine=n_vaccine,\n        model=model)\n\n각 발표된 데이터를 바탕으로 양성 환자들이 백신 접종 여부를 데이터로 만들었습니다.\n\nn_Pfizer_total = 170\nn_Pfizer_vaccine = 8\nn_Pfizer_placebo = n_Pfizer_total - n_Pfizer_vaccine\nPfizer_outcomes = np.concatenate([np.ones(n_Pfizer_vaccine), np.zeros(n_Pfizer_placebo)])\n\nn_Moderna_total = 95\nn_Moderna_vaccine = 5\nn_Moderna_placebo = n_Moderna_total - n_Moderna_vaccine\nModerna_outcomes = np.concatenate([np.ones(n_Moderna_vaccine), np.zeros(n_Moderna_placebo)])\n\nn_AstraZeneca_1_total = 37\nn_AstraZeneca_1_vaccine = 3\nn_AstraZeneca_1_placebo = n_AstraZeneca_1_total - n_AstraZeneca_1_vaccine\nAstraZeneca_1_outcomes = np.concatenate([np.ones(n_AstraZeneca_1_vaccine), np.zeros(n_AstraZeneca_1_placebo)])\n\nn_AstraZeneca_2_total = 94\nn_AstraZeneca_2_vaccine = 26\nn_AstraZeneca_2_placebo = n_AstraZeneca_2_total - n_AstraZeneca_2_vaccine\nAstraZeneca_2_outcomes = np.concatenate([np.ones(n_AstraZeneca_2_vaccine), np.zeros(n_AstraZeneca_2_placebo)])\n\n4개의 모델을 각각 만들어도 되지만, 한 모델에 4개의 정보를 모두 집어 넣었을 경우 비교하기 위한 forestplot사용이 간단해지기 때문에 같은 모델에 4개의 모델을 집어 넣어 한번에 계산해 보았습니다.\n\ndata = {\"Pfizer\": Pfizer_outcomes, \"Moderna\": Moderna_outcomes, \"AstraZeneca 1\": AstraZeneca_1_outcomes, \"AstraZeneca 2\": AstraZeneca_2_outcomes}\nmodel = pm.Model()\nfor name in data.keys():\n    model = get_efficacy_model_with_name(data[name], name, model=model)\n\n위에서와 똑같이 가장 비싼 연산인 MCMC sampling을 진행했습니다.\n\ndef get_trace(model):\n    with model:\n        trace = pm.sample(draws=5000, step=pm.HamiltonianMC(), start=pm.find_MAP(), progressbar=True)\n    return trace\n\ntrace = get_trace(model)\n\n\n\n\n\n\n    \n      \n      100.00% [13/13 00:00&lt;00:00 logp = -117.69, ||grad|| = 0.0049811]\n    \n    \n\n\n\n\n\nMultiprocess sampling (2 chains in 2 jobs)\n\n\nHamiltonianMC: [P(AstraZeneca 2 treatment | positive), P(AstraZeneca 1 treatment | positive), P(Moderna treatment | positive), P(Pfizer treatment | positive)]\n\n\n\n\n\n\n\n    \n      \n      100.00% [12000/12000 00:03&lt;00:00 Sampling 2 chains, 0 divergences]\n    \n    \n\n\nSampling 2 chains for 1_000 tune and 5_000 draw iterations (2_000 + 10_000 draws total) took 4 seconds.\n\n\n샘플링한 결과를 아래와 같이 시각화 할 수 있으며 위에서 똑같은 그래프 세트가 4개 나온 것을 볼 수 있습니다.\n\nwith model:\n    az.plot_trace(trace)\nplt.tight_layout()\nplt.show()\n\n\n\n\n각각 개별 그래프는 알아보기 어렵기 때문에 각 백신의 효과를 다 모아서 한 그래프로 표기해 보았습니다.\n\nplt.figure(figsize=(8, 8))\nsns.kdeplot(trace['Pfizer vaccine efficacy'], label='Pfizer')\nsns.distplot(trace['Moderna vaccine efficacy'], hist=False, label='Moderna')\nsns.kdeplot(trace['AstraZeneca 1 vaccine efficacy'], label='AstraZeneca regimen 1')\nsns.distplot(trace['AstraZeneca 2 vaccine efficacy'], hist=False, label='AstraZeneca regimen 2')\nplt.title(\"Posterior distributions of efficacy of different vaccines\")\nplt.legend()\nplt.savefig(\"efficacy.png\")\nplt.show();\n\n\n\n\n히스토그램 그래프로는 신용구간(credible interval)을 확인하기 다소 어렵기 때문에 백신의 신뢰구간을 모아서 비교할 수 있는 forestplot을 구해보았습니다.\n\nwith model:\n    efficacy_names = list(filter(lambda name: \"vaccine efficacy\" in name, trace.varnames))\n    pm.forestplot(trace, var_names=efficacy_names);\nplt.show()\n\n\n\n\n\n\n불확실성의 해석\n그래서 AstraZeneca 1의 백신의 평균만 보면 moderna와 비슷한 효능을 보이는 것 같지만, 불확실성이 훨씬 크기에 Moderna 만큼 좋은가에 대해서는 추가적인 조사가 필요한 것으로 보입니다. 한가지 참고할 만한 부분은 이유는 모르겠지만 AstraZeneca 1방법으로 백신을 놓고 있지는 않는 것으로 알려져 있으며 아마도 당초 설계와 다르기 때문에 그런 것으로 판단됩니다."
  },
  {
    "objectID": "posts/bayesian_approach_for_COVID-19_vaccine_efficacy/index.html#백신간의-비교는-어떻게-할까",
    "href": "posts/bayesian_approach_for_COVID-19_vaccine_efficacy/index.html#백신간의-비교는-어떻게-할까",
    "title": "COVID-19 백신 효과 측정을 위한 베이지안 접근",
    "section": "백신간의 비교는 어떻게 할까?",
    "text": "백신간의 비교는 어떻게 할까?\n위에서 진행한 방식을 조금 응용하면 백신 간 예방효과의 우월성을 비교할 수 있습니다. 간단하게 설명하자면 위에서 구하는 efficacy 분포를 서로 빼 보면 됩니다.\n\nPfizer vs. Moderna\nPfizer와 Moderna 백신을 비교해보자. 자료는 위에서 사용했던 것을 그대로 사용하고 거의 모든 것은 동일 하지만 마지막에 difference와 ralation을 구해봅니다.\n\nwith pm.Model() as model_1:\n    \n    p_Pfizer = pm.Beta('p_Pfizer', alpha=1, beta=1)\n    p_Moderna = pm.Beta('p_Moderna', alpha=1, beta=1)\n    \n    like_Pfizer = pm.Bernoulli('like_Pfizer', p=p_Pfizer, observed=Pfizer_outcomes)\n    like_Moderna = pm.Bernoulli('like_Moderna', p=p_Moderna, observed=Moderna_outcomes)\n    \n    e_Pfizer = pm.Deterministic('Pfizer Efficacy', 1 - p_Pfizer/(1-p_Pfizer))\n    e_Moderna = pm.Deterministic('Moderna Efficacy', 1 - p_Moderna/(1-p_Moderna))\n    \n    pm.Deterministic('difference', e_Pfizer-e_Moderna)\n    pm.Deterministic('relation', (e_Pfizer/e_Moderna)-1)\n    \n    trace_1 = pm.sample(draws=5000, step=pm.Metropolis(), start=pm.find_MAP(), progressbar=True)\n\n\n\n\n\n\n    \n      \n      100.00% [10/10 00:00&lt;00:00 logp = -183.68, ||grad|| = 87.95]\n    \n    \n\n\n\n\n\nMultiprocess sampling (2 chains in 2 jobs)\n\n\nCompoundStep\n\n\n&gt;Metropolis: [p_Moderna]\n\n\n&gt;Metropolis: [p_Pfizer]\n\n\n\n\n\n\n\n    \n      \n      100.00% [12000/12000 00:03&lt;00:00 Sampling 2 chains, 0 divergences]\n    \n    \n\n\nSampling 2 chains for 1_000 tune and 5_000 draw iterations (2_000 + 10_000 draws total) took 3 seconds.\n\n\nThe number of effective samples is smaller than 25% for some parameters.\n\n\npymc3에서 제공하는 기능을 활용하면 아래와 같은 그래프를 구할 수 있습니다.\n\nwith model_1:\n    _ = pm.plot_posterior(trace_1, var_names=['difference', 'relation'], ref_val=0);\nplt.show()\n\n\n\n\n이를 간단히 해석하자면 Pfizer백신이 Moderna백신보다 약간 더 나아 보이기는 합니다.(차이의 평균이 1.1%정도로 Pfizer가 높다고 해석할 수 있다.) 다만, 그 불확실성이 커서 실제로 나은 것인지 아니면 우연히 나은 것인지 판단하기는 어려운 상황입니다.\n\ndiffs_1 = trace_1.get_values('difference', burn=1000)\nprint(f\"Pfizer가 Moderna보다 나을 확률: {100*len(diffs_1[diffs_1&gt;0])*1.0/len(diffs_1):.2f}% \")\n\nPfizer가 Moderna보다 나을 확률: 62.71% \n\n\n\n\nAstrazeneca Regime 1 Vs. Regime2\n같은 방식으로 AstraZeneca의 용법 1과 용법 2를 비교해 봅니다.\n\nwith pm.Model() as model_2:\n    \n    p_regimen1 = pm.Beta('p_regimen1', alpha=1, beta=1)\n    p_regimen2 = pm.Beta('p_regimen2', alpha=1, beta=1)\n    \n    like_regimen1 = pm.Bernoulli('like_regimen1', p=p_regimen1, observed=AstraZeneca_1_outcomes)\n    like_regimen2 = pm.Bernoulli('like_regimen2', p=p_regimen2, observed=AstraZeneca_2_outcomes)\n    \n    e_regimen1 = pm.Deterministic('Regimen1 Efficacy', 1 - p_regimen1/(1-p_regimen1))\n    e_regimen2 = pm.Deterministic('Regimen2 Efficacy', 1 - p_regimen2/(1-p_regimen2))\n    \n    pm.Deterministic('difference', e_regimen1-e_regimen2)\n    pm.Deterministic('relation', (e_regimen1/e_regimen2)-1)\n    \n    trace_2 = pm.sample(draws=50000, step=pm.Metropolis(), start=pm.find_MAP(), progressbar=True)\n\n\n\n\n\n\n    \n      \n      100.00% [9/9 00:00&lt;00:00 logp = -90.802, ||grad|| = 26.101]\n    \n    \n\n\n\n\n\nMultiprocess sampling (2 chains in 2 jobs)\n\n\nCompoundStep\n\n\n&gt;Metropolis: [p_regimen2]\n\n\n&gt;Metropolis: [p_regimen1]\n\n\n\n\n\n\n\n    \n      \n      100.00% [102000/102000 00:22&lt;00:00 Sampling 2 chains, 0 divergences]\n    \n    \n\n\nSampling 2 chains for 1_000 tune and 50_000 draw iterations (2_000 + 100_000 draws total) took 23 seconds.\n\n\nThe number of effective samples is smaller than 25% for some parameters.\n\n\n결과를 시각화 하면 아래와 같다. 보면 알겠지만, 차이가 0보다 클 확률이 상당히 높은 것을 직관적으로 볼 수 있습니다.\n\nwith model_2:\n    _ = pm.plot_posterior(trace_2, var_names=['difference', 'relation'], ref_val=0);\nplt.show()\n\n\n\n\n용법 1이 용법 2보다 나을 확률이 높음을 알 수 있으며 계산해보면 99%이상 용법 1이 낫다고 볼 수 있습니다. 6%이상 나을 확률도 97% 수준으로 용법 1이 용법 2보다 훨씬 났다고 볼 수 있습니다.\n\ndiffs_2 = trace_2.get_values('difference', burn=1000)\nprint(f\"Regime1이 Regime2보다 나을 확률: {100*len(diffs_2[diffs_2&gt;0])*1.0/len(diffs_2):.2f}%\")\nprint(f\"Regime1이 Regime2보다 6%이상 나을 확률: {100*len(diffs_2[diffs_2&gt;0.06])*1.0/len(diffs_2):.2f}%\")\n\nRegime1이 Regime2보다 나을 확률: 99.24%\nRegime1이 Regime2보다 6%이상 나을 확률: 97.69%\n\n\n\nplt.figure(figsize=(12,4))\nplt.hist(diffs_2, bins=100, density=True)\nplt.vlines(0.06, 0, 6, linestyle='--', color='red')\nplt.title('Posterior distribution of the difference of the two regimens')\nplt.show();"
  },
  {
    "objectID": "posts/bayesian_approach_for_COVID-19_vaccine_efficacy/index.html#백신-효능-측정에-대한-몇가지-추가적인-고찰",
    "href": "posts/bayesian_approach_for_COVID-19_vaccine_efficacy/index.html#백신-효능-측정에-대한-몇가지-추가적인-고찰",
    "title": "COVID-19 백신 효과 측정을 위한 베이지안 접근",
    "section": "백신 효능 측정에 대한 몇가지 추가적인 고찰",
    "text": "백신 효능 측정에 대한 몇가지 추가적인 고찰\n\n실험 규모와 상관 없이 양성환자가 너무 적으면 효과가 있는지 알기 어렵다\n백신을 개발하는데 있어서 예방효과측정은 가장 중요한 과정중 하나입니다. 실험 규모가 크면 일반적으로 양성환자가 많이 발생할 것이라고 예상되지만 반드시 필요한 숫자 만큼 나오는 것은 아니라는 것입니다.\n예를 들어 지금 박멸되었다고 보고 있는 천연두를 생각해 보죠. 어떤 사람이 새로운 천연두 백신을 개발했다고 해도 우리는 그 백신이 효과가 있는지 알기 어렵습니다. 왜냐하면 양성환자가 나오지 않기 때문에 위와 같은 테스트를 할 수 없기 때문입니다.\n\n\n실험 내에서 양성 환자가 많으면 많을 수록 정확한 값을 알 수 있다\n많은 양성환자가 더 백신의 효능을 올려주는 것은 아니지만 백신의 효능을 조금 더 정확하게 알 수 있습니다.\n간단하게 생각해 보면 10명 중 1명이 양성인 경우는 운이 좋아서 10%인 건인지 아니면 운이 나빠서 10%인 것인지 알기가 어렵습니다. 한명만 추가 되거나 줄어도 비율이 20%에서 0%까지 흔들리기 때문입니다.\n하지만 100명 중 10명이라고 한다면 한명이 더 생기거나 덜 생기면 9%~11% 이기 때문에 조금더 정확하다고 판단할 수 있습니다.\n그렇기 때문에 많이 유행하고 있는 국가에서 실험을 해야 백신의 효과를 상대적으로 적은 실험을 통해서도 알 수 있게 됩니다.\n\n\n반드시 접종 vs 비접종자의 숫자가 동수일 필요는 없다\n많은 경우 실험을 할 때 양쪽의 숫자를 동수로 두고 진행하는 경향이 있는 것 같습니다. 하지만 반드시 동수로 진행 할 필요는 없으며 상황에 맞게 진행하되 나중에 결과 해석에서 조정할 수 있습니다. 다만 여러가지 알 수 없는 변수에 대한 대응 차원에서 단순하게 동수로 가는 경향이 강한 것으로 생각됩니다."
  },
  {
    "objectID": "posts/javis_retrograde_motion/index.html",
    "href": "posts/javis_retrograde_motion/index.html",
    "title": "Javis.jl를 사용해서 역행운동을 실행해 보자",
    "section": "",
    "text": "유튜브를 보는 도중에 행성의 겉보기 역행 운동에 대한 영상을 보았습니다. 행성의 역행운동이란 지구에서 보기에 행성이 반대방향으로 움직이는 것처럼 보이는 현상입니다. 행성은 태양을 중심으로 돌고 있지만, 행성 간의 공전 속도의 차이로 뒤로 움직이는 듯이 보이는 현상을 말합니다. \n행성이 있고 보이는 각이 어떻게 바뀌는지를 시뮬레이션을 해보고자 하는데 줄리아에서 애니메이션을 만들 때 사용할 수 있는 Javis를 사용해서 그려보겠습니다.\n\nusing Javis\n\nfunction ground(args...) \n    background(\"white\") # canvas background\n    sethue(\"black\") # pen color\nend\nfunction object(p=O, color=\"black\")\nsethue(color)\ncircle(p, 25, :fill)\nreturn p\nend\n\n\nfunction path!(points, pos, color)\nsethue(color)\npush!(points, pos) # add pos to points\ncircle.(points, 2, :fill) # draws a circle for each point using broadcasting\nend\n\n\nfunction connector(p1, p2, color)\nsethue(color)\nline(p1,p2, :stroke)\nend\n\n\nfunction extender(points, p1, p2, r, color)\nsethue(color)\nd = p2 - p1\np3 = getpoint(p2, d, r, O)\nline(p1, p3, :stroke)\ncircle(p3, 2, :fill)\npush!(points, p3)\nif length(points) &gt; 200\npopat!(points, 1)\nend\ncircle.(points, 2, :fill)\nend\n\n\nimport Base.abs\n\n\nfunction abs(p::Point, p0::Point)\nd = p - p0\nr = sqrt(d.x^2 + d.y^2)\nreturn r\nend\n\n\nfunction getpoint(p, d, r, p0)\nλ = 0.001\nrate = 0.001\nnew_p = p\nwhile true\nnew_p = p + λ * d\nif r &lt; abs(new_p, p0)\nbreak\nend\nλ += rate\nend\nreturn new_p\nend\n\n\nn = 1000\nmyvideo = Video(2000, 2000)\nBackground(1:n, ground)\npath_of_red = Point[]\npath_of_blue = Point[]\nred_ball = Object(1:n, (args...)-&gt;object(O, \"#ff2211\"), Point(100,0))\nact!(red_ball, Action(anim_rotate_around(24π, O)))\nblue_ball = Object(1:n, (args...)-&gt;object(O, \"#1122ff\"), Point(200,0))\nact!(blue_ball, Action(anim_rotate_around(7π, O)))\nObject(1:n, (args...)-&gt;connector(pos(red_ball), pos(blue_ball), \"black\"))\nObject(1:n, (args...)-&gt;path!(path_of_red, pos(red_ball), \"red\"))\nObject(1:n, (args...)-&gt;path!(path_of_blue, pos(blue_ball), \"blue\"))\npoints = []\nObject(1:n, (args...)-&gt;extender(points, pos(red_ball), pos(blue_ball), 800, \"#112233\"))\n\n\nrender(\nmyvideo;\npathname=\"retrograde_motion.gif\"\n)\n\n\n\n\n역행운동"
  },
  {
    "objectID": "posts/sir_model_tutorial_using_julia/index.html",
    "href": "posts/sir_model_tutorial_using_julia/index.html",
    "title": "SIR모델을 사용해 코로나 발병 예측하기 with Julia",
    "section": "",
    "text": "코로나19로 인해 감염병 모델링에 대한 관심이 높아졌습니다. 질병이 어떻게 퍼져나가는지 예측할 수 있는 건 이후 대응을 위해서도 아주 중요한 지식임을 많은 사람들이 알게 되었습니다. 여러가지 예측하는 방법이 있습니다만, 오늘은 수리 모델링을 통해서 이에 대해서 알아보고자 합니다.\n수리 모델(Methmetical Model)은 계산모델(Computational Model)이라고도 할 수 있습니다. 현상에 대해서 우리가 아는 내용을 수식으로 정리하고 이후 어떻게 변해가는지를 계산하는 방식이라고 할 수 있습니다. 감염병 확산에 대한 수리 모델은 여러가지 갈래로 발전하고 있는데 일반적으로 가장 간단한 모델로 SIR 모델를 뽑습니다."
  },
  {
    "objectID": "posts/sir_model_tutorial_using_julia/index.html#sir-모델",
    "href": "posts/sir_model_tutorial_using_julia/index.html#sir-모델",
    "title": "SIR모델을 사용해 코로나 발병 예측하기 with Julia",
    "section": "SIR 모델",
    "text": "SIR 모델\n감염병에 대한 수치적 모델의 대표적인 모델이 SIR 모델입니다. SIR은 Susceptible, Infected, Recovered의 첫 글자를 모은 것입니다. 저 3가지 상태로 사람들이 분류 된다고 보고 이에 대한 모델을 만드는 것입니다.\n이에 대해서는 당연하다고 생각되는 몇가지 가정을 수식으로 만들었습니다.\n\n새롭게 감염된 사람들의 수 만큼 미감염자(Susceptible)의 수는 줄어들 것이다.\n새롭게 감염된 사람들의 수 만큼 감염자(Infected)는 늘어날 것이다.\n새롭게 회복된 사람들의 수 만큼 감염자 수는 줄어 들 것이다.\n새롭게 회복된 인원의 수 만큼 회복된 인원(Recovered)은 늘어날 것이다.\n\n이 모델은 아래와 같이 일방향으로 사람들의 상태가 변해가는 것을 볼 수 있습니다. 따라서 장기적으로 보면 모두 회복된 사람들이 될 것입니다.\n\n\n\n\nflowchart LR\n\nSusceptible --&gt;|susceptible, infected| Infected\nInfected --&gt; Recovered\n\n\n\n\n\n\n새롭게 감염되는 사람과 새롭게 회복되는 사람에 대해서 몇가지 가정이 추가 됩니다.\n\n새롭게 감염되는 사람의 수는 이전 미감염된 사람의 수가 많을 수록 많아지며 그 수는 감염자 비율이 높을 수록 커질 것이다.\n새롭게 회복되는 사람의 수는 감염자 수가 많을 수록 많을 것이다.\n\n이 가정들을 모아서 아래와 같이 수식으로 만들 수 있습니다.\n\\[\n\\frac{dS}{dt} = - \\beta \\frac{S \\cdot I}{N}\n\\] \\[\n\\frac{dI}{dt} = \\beta \\frac{S \\cdot I}{N} - \\gamma I\n\\] \\[\n\\frac{dR}{dt} = \\gamma I\n\\]\n이제 이 아이디어를 코딩으로 옮겨 보고자 합니다."
  },
  {
    "objectID": "posts/sir_model_tutorial_using_julia/index.html#sir모델-코딩하기",
    "href": "posts/sir_model_tutorial_using_julia/index.html#sir모델-코딩하기",
    "title": "SIR모델을 사용해 코로나 발병 예측하기 with Julia",
    "section": "SIR모델 코딩하기",
    "text": "SIR모델 코딩하기\n\n\n\n\n\n\n왜 줄리아인가?\n\n\n\n줄리아는 2012년 공개된 새로운 프로그래밍 언어 입니다. 과학적 계산을 목표로 만들어진 언어로 아직 사용자는 적지만 주목을 받고 있는 언어입니다.\n인터프리터 언어인 파이썬의 느린 속도를 해결하면서도 파이썬 만큼 사용하기 쉬운 언어라고 소개되곤 합니다. 파이썬 만큼 쓰기 편한 것은 모르겠지만, 과학을 하기에는 정말 좋은 언어라고 생각합니다.\n\n\n\n필요한 패키지 설치하기\n줄리아는 Pkg 모듈을 사용해서 아래와 같이 필요한 패키지를 설치할 수 있습니다.\n줄리아 패키지 설치가 상당히 많은 시간이 소요될 수 있습니다.\n\n\nCode\nusing Pkg\n\nPkg.add([\"Turing\", \"LazyArrays\", \"Random\", \"DifferentialEquations\", \"Plots\", \"StatsPlots\", \"LaTeXStrings\", \"Downloads\", \"DataFrames\", \"CSV\", \"Chain\", \"Dates\"])"
  },
  {
    "objectID": "posts/sir_model_tutorial_using_julia/index.html#sir-모델-만들기",
    "href": "posts/sir_model_tutorial_using_julia/index.html#sir-모델-만들기",
    "title": "SIR모델을 사용해 코로나 발병 예측하기 with Julia",
    "section": "SIR 모델 만들기",
    "text": "SIR 모델 만들기\n줄리아는 위의 값을 아래와 같이 정리할 수 있습니다. du, u, p, t를 지정해야 합니다.\n여기서 p는 파라미터, t는 시간을 의미하며 u는 변수이며 du는 그 1차 미분을 의미합니다. 이것을 바탕으로 위의 수식을 최대한 비슷하게 작성할 수 있습니다.\n\n\nCode\nusing DifferentialEquations\n\nfunction sir_ode!(du, u, p, t)\n    (S, I, R) = u\n    (β, γ) = p\n    N = S + I + R    # N은 전체 인원입니다.\n    infection = β * I * S / N \n    recovery = γ * I\n    @inbounds begin\n        du[1] = -infection # u의 첫번째 아이템의 전미분인 미감염자의 비율입니다.\n        du[2] = infection - recovery # Infected\n        du[3] = recovery # Recovered\n    end\n    nothing\nend;\n\n\n붉은색 선을 보시면 감여자 수가 피크를 그리고나면 점차 줄어드는 것을 볼 수 있습니다.\n\n\nCode\nusing Plots, StatsPlots, LaTeXStrings\n\nsusceptible = 10_000_000.0\ninfected = 10.0\nrecovered = 0.0 \n\nu = [susceptible, infected, recovered]\np = [0.5, 0.03]\nprob = ODEProblem(sir_ode!, u, (1.0, 100.0), p)\nsol_ode = solve(prob)\nplot(sol_ode, label=[L\"S\" L\"I\" L\"R\"],\n    lw=3,\n    xlabel=L\"t\",\n    ylabel=L\"N\",\n    yformatter=y -&gt; string(round(Int64, y ÷ 1_000_000)) * \"mi\",\n    title=\"SIR Model for 100 days, β = $(p[1]), γ = $(p[2])\")\n\n\n\n\n\n이 그래프를 여러가지 파라미터를 바꿔가면서 그려 보면 \\(\\beta\\)는 얼마나 빠르게 올라가는지 그리고 피크가 어디에 위치하는지를 결정한다면, \\(\\gamma\\)는 피크의 높이를 결정한다는 걸 볼 수 있습니다.\n\n\nCode\nbeta = 0.1:0.3:1.0\ngamma = 0.01:0.03:0.1\n\nfunction plots(beta, gamma, susceptible, infected, recovered) \n    u = [susceptible, infected, recovered]\n    charts = []\n    for (b, g) in [(b,g) for b in beta for g in gamma]\n        p = [b, g]\n        prob = ODEProblem(sir_ode!, u, (1.0, 100.0), p)\n        sol_ode = solve(prob)\n        chart = plot(sol_ode, \n            lw=3,\n            xlabel=L\"t\",\n            yformatter=y -&gt; string(round(Int64, y ÷ 1_000_000)) * \"mi\",\n            title=\"β = $(p[1]), γ = $(p[2])\", legend=false)\n        push!(charts, chart)\n    end\n    return charts\nend\n\ncharts = plots(beta,gamma, susceptible, infected, recovered)\nmap((chart) -&gt; plot!(chart, ylabel=L\"N\"), charts[1:4:16])\n\nplot(charts..., layout=(4, 4), \nsize=(850, 800), plot_title=\"SIR Model for 100 days\", label=[L\"S\" L\"I\" L\"R\"],)"
  },
  {
    "objectID": "posts/sir_model_tutorial_using_julia/index.html#마치며",
    "href": "posts/sir_model_tutorial_using_julia/index.html#마치며",
    "title": "SIR모델을 사용해 코로나 발병 예측하기 with Julia",
    "section": "마치며",
    "text": "마치며\n간단한 가정을 가지고 모델을 만드는 것을 연습해보았습니다. 단순한 몇가지 가정만으로도 우리는 피크에 다다르는 모델을 볼 수 있었습니다. 그럼 이제 실제 데이터를 가지고 저 파라미터가 재생산지수와 어떤 관게가 있는지, 파라미터를 어떻게 알 수 있을지 다음 포스트로 알아보도록 하겠습니다."
  },
  {
    "objectID": "posts/leos_syndrome/index.html",
    "href": "posts/leos_syndrome/index.html",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "",
    "text": "이 글은 Leo’s Syndrome을 기반으로 작성하였습니다.\n재미있는 글을 발견하여 소개하고자 합니다.\n영화배우 레오나르도 디카프리오는 어린 여성과 사귀는 것으로 유명합니다. 어떤 분이 위에 글과 같이 깔끔하게 데이터 시각화를 하였는데요. 이는 Makie라고 하는 Julia 패키지를 사용하였습니다.\nMakie는 비교적 최근에 개발된 라이브러리 입니다. 여러 백엔드를 사용해서 개발할 수 있다는 특징을 가지고 있습니다만, 아직 초창기다보니 기본이 되는 백엔드는 GLMakie이며 이외에 여러가지 다양한 백엔드로 개발되고 있습니다.\n기본 문법 들을 하나 하나 살펴보도록 하겠습니다."
  },
  {
    "objectID": "posts/leos_syndrome/index.html#패키지-불러오기",
    "href": "posts/leos_syndrome/index.html#패키지-불러오기",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "패키지 불러오기",
    "text": "패키지 불러오기\n\nusing Downloads, GLMakie\nusing Colors, Statistics\nusing FileIO\n\n파이썬과 비슷하게 가장 먼저 볼 수 있는 건 패키지를 로딩하는 부분입니다. 파이썬과 같이 import를 사용할 수도 있지만, 줄리아에서는 using사용하는 것이 표준이 되는 방식입니다."
  },
  {
    "objectID": "posts/leos_syndrome/index.html#백엔드-선택하기",
    "href": "posts/leos_syndrome/index.html#백엔드-선택하기",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "백엔드 선택하기",
    "text": "백엔드 선택하기\n\nGLMakie.activate!()\n\n위에서 불러온 그래픽 패키지인 GLMakie를 활성화 시킵니다."
  },
  {
    "objectID": "posts/leos_syndrome/index.html#파일명-합치기",
    "href": "posts/leos_syndrome/index.html#파일명-합치기",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "파일명 합치기",
    "text": "파일명 합치기\n\nnames = [\"Leonardo Dicaprio\", \"Gisele Bundchen\", \"Bar Refaeli\",\n        \"Blake Lively\", \"Erin Heatherton\", \"Toni Garrn\", \"Kelly Rohrbach\",\n        \"Nina Agdal\", \"Camila Morrone\"]\nnamesfiles = join.(split.(lowercase.(names)), \"_\")\n\n이름을 정하고 파일명에 맞출 수 있도록 소문자로 변환하고 띄어쓰기를 “_“로 치환합니다. 줄리아는 Broadcasting을 .을 함수 뒤에 붙이는 것을 통해 별도의 조치 없이 적용이 가능합니다. 예를 들면 lowercase.(names)의 뜻은 name의 각 원소에 lowercase함수를 적용하라는 것과 같습니다."
  },
  {
    "objectID": "posts/leos_syndrome/index.html#축에-들어갈-값을-생성하기",
    "href": "posts/leos_syndrome/index.html#축에-들어갈-값을-생성하기",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "축에 들어갈 값을 생성하기",
    "text": "축에 들어갈 값을 생성하기\n\ny_xticks = 1998:2022\nys_xticks = string.(1998:2022)\nyd_xticks = [\"'\"*t[3:4] for t in ys_xticks]\nage_leo = 24 .+ collect(1:length(y_xticks)) .- 1\n\nage_gf = [18:23, 20:25, 23, 22, 20:21,25, 24:25, 20:25]\nyears = [1998:2003, 2004:2009, 2010, 2011, 2012:2013, 2014,\n    2015:2016, 2017:2022]\n\n각종 축에 사용될 값을 생성합니다. 줄리아에서는 :을 사용해서 연속된 정수 값을 표현할 수 있습니다. 예를 들면 1998:2022는 1998부터 2022까지 1씩 증가하는 것을 의미하며 파이썬에서 range(1998, 2023)과 동일 합니다. 줄리아는 파이썬과 다르게 범위를 포함하는 특징을 가지고 있습니다. 이는 수학에서 사용하는 것과 가능한 유사한 방식을 구현하기 위함으로 알고 있습니다.\n이름을 바꾸었던 것과 같이 string 함수를 적용해 ys_xticks를 생성했음을 알 수 있습니다. 이렇게 바꾼 이유는 뒤에 두글자만 가져와 yd_xticks를 만들기 위함 입니다.\n줄리아의 또다른 특징을 여기서 볼 수 있는데 문자열을 병합할 때 +기호가 아닌 *기호를 씁니다. 왜 이렇게 만들었는지 궁금한 부분이긴 한데 이미 많은 코드에 *가 사용되고 있고 바꾸는 실익이 거의 없다고 판단하여 유지되고 있다고 알고 있습니다.\n그다음에는 레오의 나이를 표기하고자 수열을 만들었습니다. 24 .+ collect(1:length(y_xticks)) .- 1을 통해 24살에서 1부터 길이까지의 수열을 만들고 1을 빼서 24살 부터 데이터 수 만큼 1씩 증가하는 수열을 만들었습니다. 여기서 collect라는 함수는 배열을 만드는 함수로 보시면 됩니다.\n또한 .+는 각각에 더하기 연산을 하라는 의미입니다.\n이 다음에는 레오나르도의 여자친구들의 나이와 기간이 적혀 있습니다."
  },
  {
    "objectID": "posts/leos_syndrome/index.html#사진을-불러오는-함수",
    "href": "posts/leos_syndrome/index.html#사진을-불러오는-함수",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "사진을 불러오는 함수",
    "text": "사진을 불러오는 함수\n\nfunction getPicture(; name = \"leonardo_dicaprio\",\n        imgs_link = \"https://raw.githubusercontent.com/tashapiro/tanya-data-viz/main/dicaprio-gfs/images/\")\n    load(Downloads.download(joinpath(imgs_link, name * \".png\")))\nend\n\n줄리아에서 사진을 불러오는 함수를 만들었습니다. 줄리아는 파이썬과 다르게 function이란 키워드를 사용하여 함수를 만듭니다. 또한 기본값이 있는 파라미터를 지정할 경우에는 ; 뒤에 이름과 파라미터를 넣으면 됩니다. 이 또한 파이썬과 다른 특징이라고 볼 수 있습니다.\n이 함수는 링크 주소를 생성하고 그 데이터를 불러오는 함수입니다.\n줄리아에서 함수는 return을 지정하지 않을 경우 마지막 줄을 반환하는 특징이 있습니다. 이는 함수가 상태를 변화시키는 것이 아니라 수학에서 말하는 값을 반환하는 것을 기본으로 하고 있다고 생각하기 때문에 도입된 문법이라고 생각합니다."
  },
  {
    "objectID": "posts/leos_syndrome/index.html#베지어-곡선을-만들어-주는-함수",
    "href": "posts/leos_syndrome/index.html#베지어-곡선을-만들어-주는-함수",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "베지어 곡선을 만들어 주는 함수",
    "text": "베지어 곡선을 만들어 주는 함수\n\nfunction poly3(t, p0, p1, p2, p3)\n    Point2f((1-t)^3 .* p0 .+ t*p1*(3*(1-t)^2) + p2*(3*(1-t)*t^2) .+ p3*t^3)\nend\n\n\nfunction BezierPath(o, f, co, cf; t = range(0,1, length=30))\n    return [poly3(t, o, co, cf, f) for t in t]\nend\n\n베지어 곡선을 만들기 위한 함수입니다. p0, p1, p2, p3 점을 지나는 베지어 곡선을 위해서 만들어진 함수 입니다.\n위의 poly3는 3차 함수이며 range()함수를 통해서 30개의 포인트를 부드럽게 생성하는 함수 입니다.\n\nfunction posFig(ax, x; yoff=100, ylow = 15)\n    o = ax.scene.px_area[].origin - Point2f(0, yoff)\n    return Makie.project(ax.scene, Point2f(x, ylow)) + o\nend\n\n피겨의 위치를 반환 합니다.\n\nfunction supLine(p1, p2; x=0,y=8)\n    [p1 .+ Point2f(x,y), p1, p2, p2 .+ Point2f(x,y)]\nend\n\n디긋을 어긋난 위치를 연결해서 보여줍니다."
  },
  {
    "objectID": "posts/leos_syndrome/index.html#색과-사진",
    "href": "posts/leos_syndrome/index.html#색과-사진",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "색과 사진",
    "text": "색과 사진\n\npictures = [getPicture(; name = n) for n in namesfiles]\ncmap = resample_cmap(Reverse(:Hiroshige), 9)\nblue = colorant\"#6EE2FFFF\";\ngrey = colorant\"#D0DFE699\";\n\nαcolors = [blue, blue, (grey, 0.0), (grey,0.0)]\nαcolorsLeg = [blue, (grey, 0.0), (grey,0.0), blue]\n\n위에서 정의한 함수와 색감을 정합니다. 먼저 사진을 불러와 배열에 넣습니다. 그다음으로는 색깔 맵을 구합니다. resample_cmap이란 함수는 색 간격을 나누어 줍니다. Reverse함수를 통해서 색의 방향을 반대로 만든 후 9개의 단계로 샘플링을 하게 됩니다. 그후 두 색을 별도로 지정합니다. 그 지정 방식은 메크로를 활용하고 있습니다. 줄리아에서는 메크로라는 아주 강력하지만 위험한 기능이 있습니다. colorant\"#6EE2FFFF\";은 뒤 문자열을 색 타입으로 변환하는 매크로 입니다. 여러가지를 손쉽게 처리할 수 있어 아주 강력하지만, 잘못 사용하면 코드 가독성을 많이 떨어뜨리기에 조심해서 사용해야 합니다.\n그후 여러 색의 집합을 만들었습니다."
  },
  {
    "objectID": "posts/leos_syndrome/index.html#범주를-위한-도형",
    "href": "posts/leos_syndrome/index.html#범주를-위한-도형",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "범주를 위한 도형",
    "text": "범주를 위한 도형\n\nlegleo = MarkerElement(color =1.2cmap[2:3:end], marker = :circle, markersize = 20,\n        points = Point2f[(0, 0.5), (1, 0.5), (2, 0.5)])\nleggirl = PolyElement(color = αcolorsLeg, strokecolor = :white, strokewidth = 0.85,\n    points = Point2f[(-0.2, 0), (2.2, 0), (2.2,1), (-0.2, 1)])\n\n레오나르도의 나이를 표현하기 위한 점 3개를 만들는 것과 여자친구의 나이를 나타내는 사각형을 만들었습니다."
  },
  {
    "objectID": "posts/leos_syndrome/index.html#테마-블록",
    "href": "posts/leos_syndrome/index.html#테마-블록",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "테마 블록",
    "text": "테마 블록\n\nwith_theme(theme_black()) do\n...\nend\n\n테마 블록을 통해서 여러가지 기본이 되는 테마를 적용할 수 있습니다."
  },
  {
    "objectID": "posts/leos_syndrome/index.html#그림-사이즈와-축-정하기",
    "href": "posts/leos_syndrome/index.html#그림-사이즈와-축-정하기",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "그림 사이즈와 축 정하기",
    "text": "그림 사이즈와 축 정하기\n\n    fig = Figure(; resolution = (1200,800))\n    ax = Axis(fig[1,1:9], ylabel = \"Age [Years]\", xlabel = \"\")"
  },
  {
    "objectID": "posts/leos_syndrome/index.html#그래프-그리기",
    "href": "posts/leos_syndrome/index.html#그래프-그리기",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "그래프 그리기",
    "text": "그래프 그리기\n\n    lines!(ax, y_xticks, age_leo; label = \"Leo's age\", color = age_leo,\n        linestyle = :dot, colormap = 1.2cmap[2:end])\n    scatter!(ax, y_xticks, age_leo; label = \"Leo's age\", color = age_leo,\n        markersize = 10, colormap = 1.2cmap[2:end])"
  },
  {
    "objectID": "posts/leos_syndrome/index.html#여자친구들의-나이-그래프-그리기",
    "href": "posts/leos_syndrome/index.html#여자친구들의-나이-그래프-그리기",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "여자친구들의 나이 그래프 그리기",
    "text": "여자친구들의 나이 그래프 그리기\n\n    [barplot!.(years[i], age_gf[i]; color = αcolors,label = \"Girlfriend's age\",\n        strokewidth=0.85, strokecolor= (:white,1)) for i in eachindex(years)]\n\n    [scatter!(ax, [2009,2014, 2016, 2022], fill(25 +1,4);\n        color = (blue, 0.1), markersize = 50-3i) for i in 1:10]\n\n    lines!(ax,supLine(Point2f(2009,29), Point2f(2022,29); x=0,y=-3); color=blue)\n    lines!(ax,supLine(Point2f(2014,29), Point2f(2016,29); x=0,y=-3); color=blue)\n\n    text!(ax, \"Threshold\", position = (2014,30))\n    [text!(string.(age_gf[i]), position = Point2f.(years[i], age_gf[i] .+0.5),\n        align = (:center, :bottom), fontsize = 16) for i in eachindex(age_gf)]\n\n여자친구들의 나이를 기반으로 바 그래프를 하나씩 그리도록 합니다.\n또한 임계값에 대해서 강조하기 위한 동그라미를 그립니다.\n거기에 맞게 디귿 모양의 보조선을 그립니다.\n그리고 필요한 글자를 입력합니다.\n또한 연도도 표시하도록 입력합니다."
  },
  {
    "objectID": "posts/leos_syndrome/index.html#레오나르도의-나이-입력하기",
    "href": "posts/leos_syndrome/index.html#레오나르도의-나이-입력하기",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "레오나르도의 나이 입력하기",
    "text": "레오나르도의 나이 입력하기\n\n    text!(string.(age_leo), position = Point2f.(y_xticks, age_leo .+0.5),\n        align = (:center, :bottom), fontsize = 16)\n\n레오나르도의 나이 숫자를 표시합니다."
  },
  {
    "objectID": "posts/leos_syndrome/index.html#축상-숫자-표시",
    "href": "posts/leos_syndrome/index.html#축상-숫자-표시",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "축상 숫자 표시",
    "text": "축상 숫자 표시\n\n    ax.xticks = (y_xticks, yd_xticks)\n    ax.yticks = 0:5:55\n    ylims!(ax,15,52)\n    xlims!(ax,1997,2023)\n    hidespines!.(ax)\n\n각 축의 단위를 표시하는 틱을 지정합니다.\n그후 임계값을 지정합니다.\n마지막으로 스파인을 숨깁니다."
  },
  {
    "objectID": "posts/leos_syndrome/index.html#사진-배치",
    "href": "posts/leos_syndrome/index.html#사진-배치",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "사진 배치",
    "text": "사진 배치\n\n    # pictures\n    aximgs = [Axis(fig[2,i], aspect = 1, xlabel = join(split(names[i]), \"\\n\"),\n        xlabelcolor = blue) for i in 1:9]\n    [image!(aximgs[i], rotr90(pictures[i])) for i in eachindex(pictures)]\n    hidedecorations!.(aximgs; label =false)\n    hidespines!.(aximgs)\n    aximgs[1].xlabelcolor = \"#F79D1EFF\"\n    limits!.(aximgs,1,78,1,78)\n\n사진을 배치하기 전 이름을 줄바꿈으로 만들어 둡니다.\n그 다음 그림을 붙여 넣습니다. 90도를 회전 시키는 이유는 그림의 픽셀 배치가 90 차이가 나기 때문입니다.\n그 다음 그림 표시해주는 것을 생략하시고, 그림을 그립니다. 마지막으로 첫번째 그림의 색에 맞게 글자 색을 변경하고 그림 크기를 지정합니다."
  },
  {
    "objectID": "posts/leos_syndrome/index.html#곡선으로-연결하기",
    "href": "posts/leos_syndrome/index.html#곡선으로-연결하기",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "곡선으로 연결하기",
    "text": "곡선으로 연결하기\n\n# connecting lines in fig space!\n    ops = [posFig(ax, mean(years[i]); yoff=250, ylow = 15) for i in 1:8]\n    fps = [posFig(aximgs[i], 39; yoff=120, ylow = 78) for i in 2:9]\n    supls = [supLine(posFig(ax, years[i][begin]; yoff=250, ylow = 15),\n        posFig(ax, years[i][end], yoff=250, ylow = 15)) for i in 1:8]\n    [lines!(fig.scene, supls[k], color = 1.2cmap[k+1]) for k in 1:8]\n    [lines!(fig.scene, BezierPath(ops[k], fps[k], [ops[k][1],ops[k][2]-30],\n        [fps[k][1],fps[k][2]+30]); color = 1.2cmap[k+1]) for k in 1:8]\n\n시작지점과 끝지점의 위치를 지정합니다. supls를 통해 위치를 지정하고 해당 점을 연결하여 디귿 모양의 부분을 먼저 생성합니다. 그 후 가운데 부분에 해당하는 위치에 맞도록 베지어 곡선을 통해 부드럽게 연결합니다."
  },
  {
    "objectID": "posts/leos_syndrome/index.html#제목과-마무리",
    "href": "posts/leos_syndrome/index.html#제목과-마무리",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "제목과 마무리",
    "text": "제목과 마무리\n\n    rowsize!(fig.layout,2,Auto(0.2))\n    rowgap!(fig.layout, 60)\n    Legend(fig[1,1], [legleo, leggirl], [\"      Leo's age\", \"      Girlfriend's age\"],\n        halign = :left, valign = :top,tellheight=false,tellwidth=false,\n        margin = (30, 10, 10, 10), framecolor = (:white,0.2))\n    Label(fig[0,:], \"Leo's Syndrome\", color = \"#F79D1EFF\", textsize = 32)\n\n레이아웃을 조정하고 간격을 조정합니다. 이전에 생성해 둔 모양을 가지고 범례를 만듭니다.\n그 후 레이블을 활용해 제목을 만듭니다."
  },
  {
    "objectID": "posts/leos_syndrome/index.html#마무리",
    "href": "posts/leos_syndrome/index.html#마무리",
    "title": "Leo’s Syndrome with Julia Makie",
    "section": "마무리",
    "text": "마무리\n이 모든 과정을 다 모아서 아래와 같이 작성하면 위에서 보았던 이미지를 얻을 수 있습니다.\n이 모든 과정을 통해 우리는 Makie를 통해 어떻게 그림을 그릴 수 있는지 알 수 있었습니다.\n자동으로 위치를 잡아주고 연결해주는 등의 편의 기능은 부족하기에 실무에서 효과적일지에 대해서는 좀 더 알아보아야 할 것 같습니다.\n\nusing Downloads, GLMakie\nusing Colors, Statistics\nusing FileIO\n\nGLMakie.activate!()\n# some data\nnames = [\"Leonardo Dicaprio\", \"Gisele Bundchen\", \"Bar Refaeli\",\n        \"Blake Lively\", \"Erin Heatherton\", \"Toni Garrn\", \"Kelly Rohrbach\",\n        \"Nina Agdal\", \"Camila Morrone\"]\nnamesfiles = join.(split.(lowercase.(names)), \"_\")\n\ny_xticks = 1998:2022\nys_xticks = string.(1998:2022)\nyd_xticks = [\"'\"*t[3:4] for t in ys_xticks]\nage_leo = 24 .+ collect(1:length(y_xticks)) .- 1\n\nage_gf = [18:23, 20:25, 23, 22, 20:21,25, 24:25, 20:25]\nyears = [1998:2003, 2004:2009, 2010, 2011, 2012:2013, 2014,\n    2015:2016, 2017:2022]\n# helper functions\n# Inspired by https://github.com/tashapiro/tanya-data-viz/tree/main/dicaprio-gfs\nfunction getPicture(; name = \"leonardo_dicaprio\",\n        imgs_link = \"https://raw.githubusercontent.com/tashapiro/tanya-data-viz/main/dicaprio-gfs/images/\")\n    load(Downloads.download(joinpath(imgs_link, name * \".png\")))\nend\nfunction poly3(t, p0, p1, p2, p3)\n    Point2f((1-t)^3 .* p0 .+ t*p1*(3*(1-t)^2) + p2*(3*(1-t)*t^2) .+ p3*t^3)\nend\nfunction BezierPath(o, f, co, cf; t = range(0,1, length=30))\n    return [poly3(t, o, co, cf, f) for t in t]\nend\nfunction posFig(ax, x; yoff=100, ylow = 15)\n    o = ax.scene.px_area[].origin - Point2f(0, yoff)\n    return Makie.project(ax.scene, Point2f(x, ylow)) + o\nend\nfunction supLine(p1, p2; x=0,y=8)\n    [p1 .+ Point2f(x,y), p1, p2, p2 .+ Point2f(x,y)]\nend\n\npictures = [getPicture(; name = n) for n in namesfiles]\ncmap = resample_cmap(Reverse(:Hiroshige), 9)\nblue = colorant\"#6EE2FFFF\";\ngrey = colorant\"#D0DFE699\";\n# αcolors = [blue, grey, (grey, 0.1), (blue,0.65)] # try this one 😄\nαcolors = [blue, blue, (grey, 0.0), (grey,0.0)]\nαcolorsLeg = [blue, (grey, 0.0), (grey,0.0), blue]\n\nlegleo = MarkerElement(color =1.2cmap[2:3:end], marker = :circle, markersize = 20,\n        points = Point2f[(0, 0.5), (1, 0.5), (2, 0.5)])\nleggirl = PolyElement(color = αcolorsLeg, strokecolor = :white, strokewidth = 0.85,\n    points = Point2f[(-0.2, 0), (2.2, 0), (2.2,1), (-0.2, 1)])\n\nwith_theme(theme_black()) do\n    fig = Figure(; resolution = (1200,800))\n    ax = Axis(fig[1,1:9], ylabel = \"Age [Years]\", xlabel = \"\")\n    lines!(ax, y_xticks, age_leo; label = \"Leo's age\", color = age_leo,\n        linestyle = :dot, colormap = 1.2cmap[2:end])\n    scatter!(ax, y_xticks, age_leo; label = \"Leo's age\", color = age_leo,\n        markersize = 10, colormap = 1.2cmap[2:end])\n    [barplot!.(years[i], age_gf[i]; color = αcolors,label = \"Girlfriend's age\",\n        strokewidth=0.85, strokecolor= (:white,1)) for i in eachindex(years)]\n    [scatter!(ax, [2009,2014, 2016, 2022], fill(25 +1,4);\n        color = (blue, 0.1), markersize = 50-3i) for i in 1:10]\n    lines!(ax,supLine(Point2f(2009,29), Point2f(2022,29); x=0,y=-3); color=blue)\n    lines!(ax,supLine(Point2f(2014,29), Point2f(2016,29); x=0,y=-3); color=blue)\n    text!(ax, \"Threshold\", position = (2014,30))\n    [text!(string.(age_gf[i]), position = Point2f.(years[i], age_gf[i] .+0.5),\n        align = (:center, :bottom), fontsize = 16) for i in eachindex(age_gf)]\n    text!(string.(age_leo), position = Point2f.(y_xticks, age_leo .+0.5),\n        align = (:center, :bottom), fontsize = 16)\n    ax.xticks = (y_xticks, yd_xticks)\n    ax.yticks = 0:5:55\n    ylims!(ax,15,52)\n    xlims!(ax,1997,2023)\n    hidespines!.(ax)\n    # pictures\n    aximgs = [Axis(fig[2,i], aspect = 1, xlabel = join(split(names[i]), \"\\n\"),\n        xlabelcolor = blue) for i in 1:9]\n    [image!(aximgs[i], rotr90(pictures[i])) for i in eachindex(pictures)]\n    hidedecorations!.(aximgs; label =false)\n    hidespines!.(aximgs)\n    aximgs[1].xlabelcolor = \"#F79D1EFF\"\n    limits!.(aximgs,1,78,1,78)\n    # connecting lines in fig space!\n    ops = [posFig(ax, mean(years[i]); yoff=250, ylow = 15) for i in 1:8]\n    fps = [posFig(aximgs[i], 39; yoff=120, ylow = 78) for i in 2:9]\n    supls = [supLine(posFig(ax, years[i][begin]; yoff=250, ylow = 15),\n        posFig(ax, years[i][end], yoff=250, ylow = 15)) for i in 1:8]\n    [lines!(fig.scene, supls[k], color = 1.2cmap[k+1]) for k in 1:8]\n    [lines!(fig.scene, BezierPath(ops[k], fps[k], [ops[k][1],ops[k][2]-30],\n        [fps[k][1],fps[k][2]+30]); color = 1.2cmap[k+1]) for k in 1:8]\n    rowsize!(fig.layout,2,Auto(0.2))\n    rowgap!(fig.layout, 60)\n    Legend(fig[1,1], [legleo, leggirl], [\"      Leo's age\", \"      Girlfriend's age\"],\n        halign = :left, valign = :top,tellheight=false,tellwidth=false,\n        margin = (30, 10, 10, 10), framecolor = (:white,0.2))\n    Label(fig[0,:], \"Leo's Syndrome\", color = \"#F79D1EFF\", textsize = 32)\n    fig\n    save(\"leo.png\", fig)\nend"
  },
  {
    "objectID": "posts/lineplot_following_economist_visual_guide/index.html",
    "href": "posts/lineplot_following_economist_visual_guide/index.html",
    "title": "Economist 시각화 가이드를 matplotlib에 적용하기",
    "section": "",
    "text": "Economist는 영국에서 발간하는 경제 주간지로 전세계에 일어나고 있는 뉴스를 전달합니다. 뉴스를 전달하는 과정에서 여러가지 차트를 제시하곤 하는데, 설득력 있게 전달하는 방식을 matplotlib에서 적용을 해보고자 합니다.\n예시로 사용할 데이터는 한스 로슬링 박사님이 사용하셨던 gap minder 데이터를 사용해보고자 합니다.\n우선 필요한 패키지를 불러옵니다.\n\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\ngapminder = pd.read_csv(\"https://raw.githubusercontent.com/OHI-Science/data-science-training/master/data/gapminder.csv\")\n\n\n기본 그래프 출력하기\nmatplotlib에서 기본적으로 출력할 수 있는 방식은 다음과 같습니다. seaborn을 쓰면 조금 다르겠지만, 크게 다르지 않습니다.\n\ncountries = ['United Kingdom', 'United States', 'France', 'China', 'Japan', 'Korea Rep.', 'Ghana', 'Somalia', 'South Africa',]\n\ndata = gapminder.loc[gapminder.country.isin(countries)]\nfig, ax = plt.subplots(1, 1)\n\nfor country, df in gapminder.groupby(\"country\"):\n    ax.plot(df[\"year\"], df[\"lifeExp\"], label=country)\n\nplt.show()\n\n\n\n\n보시면 알겠지만, 너무 많은 선이 노출되어 있어서 무엇을 전달하려고 하는지 전달이 되지 않습니다. 전반적으로 기대 수명이 개선 되고 있는 것을 확인할 수 있습니다만, 너무 복잡해서 무엇을 전달하고자 하는지 이해가 되지 않습니다.\n\n\n스타일 적용하기\nEconomist에서 방식은 메시지를 집중하는 방식을 사용합니다.\n앞으로 진행해보고자 하는 것을 정리하자면\n\n비교하고자 하는 자료를 강조하고 그 외의 자료는 간략하게\n세로축과 보조선을 제외하기\n가로선을 설정하기\n태그 넣기\n\n정도 입니다. 아래에 그 방식을 따라하면 됩니다.\n\n# 플롯 설정하기\nfig, ax = plt.subplots(figsize=(8,6))\n\n# 1. 보조선 그리기\n# zorder를 통해서 보여지는 순서를 지정할 수 있습니다.\n\nax.yaxis.set_ticks(range(25, 100, 15))\nax.grid(which=\"major\", axis='y', color='#758D99', alpha=0.6, zorder=1, )\n\n# 불필요한 테두리 제거하기\nax.spines[['top','right','left']].set_visible(False)\n\n# 축 눈금 스타일 조정하기\nax.set_yticklabels(ax.get_yticklabels(),            # Set labels again\n                   ha = 'right',                 # Set horizontal alignment to right\n                   verticalalignment='bottom')   # Set vertical alignment to make labels on top of gridline      \n\n\nax.yaxis.set_tick_params(pad=11,             # Pad tick labels so they don't go over y-axis\n                         labeltop=True,      # Put x-axis labels on top\n                         labelbottom=False,  # Set no x-axis labels on bottom\n                         bottom=False,       # Set no ticks on bottom\n                         labelsize=11)       # Set tick label size\n\nax.xaxis.set_tick_params(labelsize=11)        # Set tick label size\n\n\n# Economist 스타일 넣기\nax.plot([0.12, .9],                  # Set width of line\n        [.98, .98],                  # Set height of line\n        transform=fig.transFigure,   # Set location relative to plot\n        clip_on=False, \n        color='#E3120B', \n        linewidth=.6)\nax.add_patch(plt.Rectangle((0.12,.98),                 # Set location of rectangle by lower left corder\n                           0.04,                       # Width of rectangle\n                           -0.02,                      # Height of rectangle. Negative so it goes down.\n                           facecolor='#E3120B', \n                           transform=fig.transFigure, \n                           clip_on=False, \n                           linewidth = 0))\n\n\n# Plot data\n# Loop through country names and plot each one.\nfor name, df in gapminder.groupby(\"country\"):\n    ax.plot(df['year'], \n            df['lifeExp'], \n            color='#758D99', \n            alpha=0.1, \n            linewidth=3)\n\n# Plot US and China separately\nax.plot(data[data['country'] == 'United States']['year'], \n        data[data['country'] == 'United States']['lifeExp'], \n        color='#006BA2',\n        linewidth=3)\n\nax.plot(data[data['country'] == 'China']['year'], \n        data[data['country'] == 'China']['lifeExp'], \n        color='#DB444B',\n        linewidth=3)\n\n\nax.plot(data[data['country'] == 'Korea Rep.']['year'], \n        data[data['country'] == 'Korea Rep.']['lifeExp'], \n        color='#3EBCD2',\n        linewidth=3)\n\n\n# y 범위 설정하기\nax.set_ylim(25, 100)\n\n# x 범위 설정하기\nax.set_xlim(1952, 2008)\n\n# 레이블 넣기\nax.text(x=.25, y=.63, s='United States', transform=fig.transFigure, size=10, alpha=.9, color=\"#006BA2\")\nax.text(x=.7, y=.52, s='China', transform=fig.transFigure, size=10, alpha=.9, color=\"#DB444B\")\nax.text(x=.2, y=.45, s='Korea Rep.', transform=fig.transFigure, size=10, alpha=.9, color=\"#3EBCD2\")\n\n\n\n# 타이틀과 서브타이틀 넣기\nax.text(x=0.12, y=.91, s=\"Life Expectation\", transform=fig.transFigure, ha='left', fontsize=13, weight='bold', alpha=.8)\nax.text(x=0.12, y=.86, s=\"Various countries, 1952-2007\", transform=fig.transFigure, ha='left', fontsize=11, alpha=.8)\n\n# 출처 넣기\nax.text(x=0.12, y=0.01, s=\"\"\"Source: \"GAP minder\"\"\", transform=fig.transFigure, ha='left', fontsize=9, alpha=.7)\n\nplt.savefig(\"life_exp.png\")\nplt.show()"
  },
  {
    "objectID": "posts/regression_using_jax/index.html",
    "href": "posts/regression_using_jax/index.html",
    "title": "Jax를 사용해서 Regression을 그려 봅시다",
    "section": "",
    "text": "설치하기\nJAX를 설치해 봅시다. 설치를 할 때 먼저 jaxlib을 설치하고 그 버전에 맞는 jax를 설치합니다. 순서가 바뀐 경우 잘 안되는 문제가 발생하곤 했습니다.\npip install jaxlib\npip install jax==0.3.15\n\n\n필요한 패키지를 불러옵니다\n\nfrom jax import numpy as jnp\nfrom jax import grad\nimport numpy as np\nfrom plotnine import *\nimport pandas as pd\nfrom tqdm import tqdm\n\n간단한 모형을 만들어 봅니다. X와 y가 2차함수 형태로 결합된 경우를 생각해 봅니다.\n\nn = 100\nX = np.random.uniform(0, 3, size=n)\ny = 3 * np.power(X, 2) + np.random.normal(10, 3, size=n)\n\ndata = pd.DataFrame(zip(X, y), columns=[\"X\", \"y\"])\n(\n    ggplot(data)\n    + aes(\"X\", \"y\")\n    + geom_point()\n)\n\n\n\n\n&lt;ggplot: (8785277175537)&gt;\n\n\n선형 모델을 먼저 생각해 봅니다.\n\nw = {\"a\": 0., \"b\": 0.}\n\n# set model\ndef model(w, X):\n    return w[\"a\"] * X + w[\"b\"]\n\n# set loss\ndef loss(w, model, X, y):\n    return jnp.power(model(w, X) - y, 2).sum()\n\n# grad loss\ndloss = grad(loss)\n\n이제 경사하강법을 활용하여 w를 찾아봅니다.\n경사하강법은 말그대로 경사를 구해서 낮은 쪽으로 이동하게 하는 것입니다.\n기본적인 아이디어는 예측치와 관측값의 차이를 합치는 손실함수(loss function)을 구합니다. 그리고 파라미터를 손실이 줄어드는 방향(경사, 미분해서 보통 구합니다)으로 조금씩 옮겨가면서 최적의 값을 찾아 한발 한발 나아가는 방식입니다.\n수식으로 간단하게 표기해보자면 \\[Loss = ￦sum_i f(w, data_i)\\] 로 정의하고 \\(\\sum_i f(w, data_i)\\)를 \\(w\\)로 미분해서 해당 미분값(경사)를 이용해서 낮추는 방향으로 파라미터를 바꿔가면서 찾아가는 방식입니다.\n\nrate = 0.0001\n\nlosses = []\nws = []\nfor i in tqdm(range(100)):\n    l = loss(w, model, X, y)\n    ws.append(w.copy())\n    losses.append(l)\n    dw = dloss(w, model, X, y)\n    for key in w.keys():\n        w[key] -= dw[key]*rate \n\n  0%|          | 0/100 [00:00&lt;?, ?it/s]\n\n\nWARNING:jax._src.lib.xla_bridge:No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)\n\n\n  1%|          | 1/100 [00:01&lt;02:19,  1.41s/it]\n\n\n 10%|█         | 10/100 [00:01&lt;00:10,  8.89it/s]\n\n\n 33%|███▎      | 33/100 [00:01&lt;00:01, 34.41it/s]\n\n\n 52%|█████▏    | 52/100 [00:01&lt;00:00, 55.99it/s]\n\n\n 72%|███████▏  | 72/100 [00:01&lt;00:00, 79.65it/s]\n\n\n 97%|█████████▋| 97/100 [00:01&lt;00:00, 112.24it/s]\n\n\n100%|██████████| 100/100 [00:01&lt;00:00, 51.56it/s]\n\n\n\n\n\n\n# overlay plots\nresult_df = pd.DataFrame(zip(X, np.array(model(w, X))), columns=[\"X\", \"f\"])\n(\n    ggplot(data=data) +\n    aes(\"X\", \"y\") +\n    geom_point() +\n    geom_smooth(method=\"lm\") +\n    geom_line(data=result_df, mapping=aes(\"X\", \"f\"),  color=\"#ff1234\")\n    \n)\n\n\n\n\n&lt;ggplot: (8785277027825)&gt;\n\n\n\ndfs = [pd.DataFrame(zip(map(int, np.ones_like(X)*i), X, np.array(model(ws[i], X))), columns=[\"i\", \"X\", \"f\"]) for i in range(0, 50, 5)]\ndf = pd.concat(dfs)\n\n처음에는 많이 차이나지만 점점 해석적으로 계산한 선형 회귀 값과 유사해지는 것을 볼 수 있습니다.\n이 경사하강법의 장점은 손실함수를 정의 할 수만 있다면 적용할 수 있어 유연하게 많은 곳에 적용할 수 있습니다.\n\np = (\n    ggplot(data=df) +\n    aes(x=\"X\", y=\"f\") +\n    geom_point(data=data, mapping=aes(\"X\", \"y\")) +\n    geom_smooth(data=data, method=\"lm\", mapping=aes(\"X\", \"y\"), color=\"yellow\") +\n    geom_line(color=\"red\", size=1) +\n    facet_wrap(\"i\")\n)\np\n\n\n\n\n&lt;ggplot: (8785276951784)&gt;\n\n\n하나의 그래프에 겹쳐서 표현하면 아래와 같은 그래프가 됩니다.\n\np = (ggplot() +\n    geom_point(data=data, mapping=aes(\"X\", \"y\")) +\n    geom_smooth(data=data, method=\"lm\", mapping=aes(\"X\", \"y\"), color=\"yellow\")\n)\n\nfor df in dfs:\n    p += geom_line(data=df, mapping=aes(x=\"X\", y=\"f\", color=\"i\"))\n\n\np\n\n\n\n\n&lt;ggplot: (8785277181037)&gt;"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "업무를 위한 데이터 과학 레시피",
    "section": "",
    "text": "Leo’s Syndrome with Julia Makie\n\n\n\n\n\n\n\njulia\n\n\nvisualization\n\n\nmakie\n\n\n\n\n\n\n\n\n\n\n\nDec 16, 2022\n\n\n\n\n\n\n  \n\n\n\n\nSIR모델을 사용해 코로나 발병 예측하기 with Julia\n\n\n\n\n\n\n\n\n\n\n\n\nNov 15, 2022\n\n\n\n\n\n\n  \n\n\n\n\nEconomist 시각화 가이드를 matplotlib에 적용하기\n\n\n\n\n\n\n\npython\n\n\nplot\n\n\nvisualization\n\n\nmatplotlib\n\n\n\n\n\n\n\n\n\n\n\nNov 2, 2022\n\n\n\n\n\n\n  \n\n\n\n\nJax를 사용해서 Regression을 그려 봅시다\n\n\n\n\n\n\n\npython\n\n\njax\n\n\nregression\n\n\ntutorial\n\n\n\n\n\n\n\n\n\n\n\nAug 22, 2022\n\n\n\n\n\n\n  \n\n\n\n\nJavis.jl를 사용해서 역행운동을 실행해 보자\n\n\n\n\n\n\n\nretrograde motion\n\n\nvisualization\n\n\njavis\n\n\njulia\n\n\n\n\n\n\n\n\n\n\n\nFeb 3, 2022\n\n\n\n\n\n\n  \n\n\n\n\n오프라인에서 패키지 설치하기\n\n\n\n\n\n\n\npython\n\n\nsetup\n\n\ntroubleshooting\n\n\nknowhow\n\n\n\n\n\n\n\n\n\n\n\nDec 23, 2021\n\n\n\n\n\n\n  \n\n\n\n\nCOVID-19 백신 효과 측정을 위한 베이지안 접근\n\n\n\n\n\n\n\npython\n\n\nbayesian\n\n\nstatistics\n\n\nvaccine efficacy\n\n\n\n\n\n\n\n\n\n\n\nSep 25, 2021\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "데이터 과학에 관련된 코드와 지식을 공유하고자 합니다. 데이터를 통한 의사결정에 관심이 많습니다."
  },
  {
    "objectID": "posts/bayesian_approach_for_COVID-19_vaccine_efficacy/index.html#질문의-시작-백신의-성능은-어떻게-측정한-걸까",
    "href": "posts/bayesian_approach_for_COVID-19_vaccine_efficacy/index.html#질문의-시작-백신의-성능은-어떻게-측정한-걸까",
    "title": "COVID-19 백신 효과 측정을 위한 베이지안 접근",
    "section": "",
    "text": "towardsdatascience의 한 포스트를 보았습니다. 베이지안 모델링을 백신 모델링에 사용한 글인데 이 글을 보고 백신의 효능을 측정하는데 있어 어떻게 통계 모델을 구성 하게 되는지 따라해 보면서 간단하게 정리해 보고자 합니다.\n\n\n뉴스에서 나오는 백신의 예방효과를 보통 퍼센트로 나타내곤 합니다. 화이자 백신은 95%이고, 아스트라제네카는 70%대의 예방률이 나온다고 하는 등 퍼센트로 예방효과를 설명하고 있는데요. 이 숫자들의 의미는 무엇일까요?\n단순하게 생각해 보면 화이자 백신을 맞으면 95% 확률로 코로나에 걸리지 않는 것으로 해석하기 쉬운데요. 대략적으로는 맞다고 할 수 있지만 엄밀하게 보면 틀린 해석입니다.\n좀 더 정확한 표현은 백신을 맞지 않은 사람보다 백신 맞은 사람이 코로나에 걸릴 확률이 95% 적다는 뜻입니다. 분모에 들어가는 기준이 되는 값이 백신을 맞지 않은 사람이 코로나에 걸릴 확률 인 것입니다. 즉 백신을 맞지 않은 사람 대비 백신을 맞은 사람의 코로나에 걸릴 확률이 백신의 예방효과에서 말하는 퍼센트의 의미입니다.\n수식으로 정리를 해보자면 아래와 같습니다.\n\\[\\text{Vaccine efficacy} = 100 \\cdot (1 - IRR)\\] \\[IRR = \\frac{\\text{vaccine incidence rate}}{\\text{placebo incidence rate}}\\]\nIRR(Incidence Rate Ratio)는 백신 접종자와 미접종자 간 코로나에 감염된 확률의 비율입니다.\n따라서 95% 비율로 코로나 감여 확률이 줄어 들었다고 이야기는 백신을 맞은 사람들은 맞지 않은 사람들보다 95% 코로나에 덜 걸렸다는 뜻입니다.\n일반적으로 신약을 출시할 때 글로벌 스탠다드는 무작위 대조 실험(RCT)를 진행해야 합니다. 일반적으로는 논문이 출간 된 다음에야 결과를 알 수 있는데, 2020년 당시에는 뉴스에서 간단하게 결과가 공개되어 확인할 수 있었습니다."
  }
]