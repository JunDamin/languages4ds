{
  "hash": "05097ac60d0a6d462b2b7ead6bc80528",
  "result": {
    "markdown": "---\ntitle: SIR모델을 사용해 코로나 발병 예측하기 with Julia\ndate: '2022-11-15'\ncagetory:\n  - julia\n  - bayesian\n  - statistics\n  - tutorial\noutput: true\nwarning: false\ncode-fold: true\nimage: sir_model.png\n---\n\n코로나19로 인해 감염병 모델링에 대한 관심이 높아졌습니다. \n질병이 어떻게 퍼져나가는지 예측할 수 있는 건 이후 대응을 위해서도 아주 중요한 지식임을 많은 사람들이 알게 되었습니다.\n여러가지 예측하는 방법이 있습니다만, 오늘은 수리 모델링을 통해서 이에 대해서 알아보고자 합니다.\n\n수리 모델(Methmetical Model)은 계산모델(Computational Model)이라고도 할 수 있습니다.\n현상에 대해서 우리가 아는 내용을 수식으로 정리하고 이후 어떻게 변해가는지를 계산하는 방식이라고 할 수 있습니다.\n감염병 확산에 대한 수리 모델은 여러가지 갈래로 발전하고 있는데 일반적으로 가장 간단한 모델로 SIR 모델를 뽑습니다.\n\n## SIR 모델\n\n감염병에 대한 수치적 모델의 대표적인 모델이 SIR 모델입니다. \nSIR은 Susceptible, Infected, Recovered의 첫 글자를 모은 것입니다.\n저 3가지 상태로 사람들이 분류 된다고 보고 이에 대한 모델을 만드는 것입니다.\n\n이에 대해서는 당연하다고 생각되는 몇가지 가정을 수식으로 만들었습니다. \n\n- 새롭게 감염된 사람들의 수 만큼 미감염자(Susceptible)의 수는 줄어들 것이다.\n- 새롭게 감염된 사람들의 수 만큼 감염자(Infected)는 늘어날 것이다.\n- 새롭게 회복된 사람들의 수 만큼 감염자 수는 줄어 들 것이다.\n- 새롭게 회복된 인원의 수 만큼 회복된 인원(Recovered)은 늘어날 것이다.\n\n이 모델은 아래와 같이 일방향으로 사람들의 상태가 변해가는 것을 볼 수 있습니다.\n따라서 장기적으로 보면 모두 회복된 사람들이 될 것입니다.\n\n\n```{mermaid}\nflowchart LR\n\nSusceptible -->|susceptible, infected| Infected\nInfected --> Recovered\n\n```\n\n\n새롭게 감염되는 사람과 새롭게 회복되는 사람에 대해서 몇가지 가정이 추가 됩니다.\n\n- 새롭게 감염되는 사람의 수는 이전 미감염된 사람의 수가 많을 수록 많아지며 그 수는 감염자 비율이 높을 수록 커질 것이다.\n- 새롭게 회복되는 사람의 수는 감염자 수가 많을 수록 많을 것이다.\n\n이 가정들을 모아서 아래와 같이 수식으로 만들 수 있습니다.\n\n$$\n\\frac{dS}{dt} = - \\beta \\frac{S \\cdot I}{N}\n$$\n$$\n\\frac{dI}{dt} = \\beta \\frac{S \\cdot I}{N} - \\gamma I \n$$\n$$\n\\frac{dR}{dt} = \\gamma I\n$$\n\n\n이제 이 아이디어를 코딩으로 옮겨 보고자 합니다.\n\n## SIR모델 코딩하기 \n\n\n:::{.callout-note}\n### 왜 줄리아인가? \n\n줄리아는 2012년 공개된 새로운 프로그래밍 언어 입니다. 과학적 계산을 목표로 만들어진 언어로 아직 사용자는 적지만 주목을 받고 있는 언어입니다.\n\n인터프리터 언어인 파이썬의 느린 속도를 해결하면서도 파이썬 만큼 사용하기 쉬운 언어라고 소개되곤 합니다. 파이썬 만큼 쓰기 편한 것은 모르겠지만, 과학을 하기에는 정말 좋은 언어라고 생각합니다.\n\n:::\n\n### 필요한 패키지 설치하기\n\n줄리아는  Pkg 모듈을 사용해서 아래와 같이 필요한 패키지를 설치할 수 있습니다.\n\n줄리아 패키지 설치가 상당히 많은 시간이 소요될 수 있습니다.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Pkg\n\nPkg.add([\"Turing\", \"LazyArrays\", \"Random\", \"DifferentialEquations\", \"Plots\", \"StatsPlots\", \"LaTeXStrings\", \"Downloads\", \"DataFrames\", \"CSV\", \"Chain\", \"Dates\"])\n```\n:::\n\n\n## SIR 모델 만들기\n\n줄리아는 위의 수식을 아래와 같이 정리할 수 있습니다.\ndu, u, p, t를 지정해야 합니다. \n\n여기서 p는 파라미터, t는 시간을 의미하며 u는 변수이며 du는 그 1차 미분을 의미합니다.\n이것을 바탕으로 위의 수식을 최대한 비슷하게 작성할 수 있습니다.\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing DifferentialEquations\n\nfunction sir_ode!(du, u, p, t)\n    (S, I, R) = u\n    (β, γ) = p\n    N = S + I + R    # N은 전체 인원입니다.\n    infection = β * I * S / N \n    recovery = γ * I\n    @inbounds begin\n        du[1] = -infection # u의 첫번째 아이템의 전미분인 미감염자의 비율입니다.\n        du[2] = infection - recovery # Infected\n        du[3] = recovery # Recovered\n    end\n    nothing\nend;\n```\n:::\n\n\n붉은색 선을 보시면 감여자 수가 피크를 그리고나면 점차 줄어드는 것을 볼 수 있습니다.\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nusing Plots, StatsPlots, LaTeXStrings\n\nsusceptible = 10_000_000.0\ninfected = 10.0\nrecovered = 0.0 \n\nu = [susceptible, infected, recovered]\np = [0.5, 0.03]\nprob = ODEProblem(sir_ode!, u, (1.0, 100.0), p)\nsol_ode = solve(prob)\nplot(sol_ode, label=[L\"S\" L\"I\" L\"R\"],\n    lw=3,\n    xlabel=L\"t\",\n    ylabel=L\"N\",\n    yformatter=y -> string(round(Int64, y ÷ 1_000_000)) * \"mi\",\n    title=\"SIR Model for 100 days, β = $(p[1]), γ = $(p[2])\")\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n![](index_files/figure-html/cell-4-output-1.svg){}\n:::\n:::\n\n\n이 그래프를 여러가지 파라미터를 바꿔가면서 그려 보면 $\\beta$는 얼마나 빠르게 올라가는지 그리고 피크가 어디에 위치하는지를 결정한다면, $\\gamma$는 피크의 높이를 결정한다는 걸 볼 수 있습니다.\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nbeta = 0.1:0.3:1.0\ngamma = 0.01:0.03:0.1\n\nfunction plots(beta, gamma, susceptible, infected, recovered) \n    u = [susceptible, infected, recovered]\n    charts = []\n    for (b, g) in [(b,g) for b in beta for g in gamma]\n        p = [b, g]\n        prob = ODEProblem(sir_ode!, u, (1.0, 100.0), p)\n        sol_ode = solve(prob)\n        chart = plot(sol_ode, \n            lw=3,\n            xlabel=L\"t\",\n            yformatter=y -> string(round(Int64, y ÷ 1_000_000)) * \"mi\",\n            title=\"β = $(p[1]), γ = $(p[2])\", legend=false)\n        push!(charts, chart)\n    end\n    return charts\nend\n\ncharts = plots(beta,gamma, susceptible, infected, recovered)\nmap((chart) -> plot!(chart, ylabel=L\"N\"), charts[1:4:16])\n\nplot(charts..., layout=(4, 4), \nsize=(850, 800), plot_title=\"SIR Model for 100 days\", label=[L\"S\" L\"I\" L\"R\"],)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n![](index_files/figure-html/cell-5-output-1.svg){}\n:::\n:::\n\n\n## 마치며 \n\n간단한 가정을 가지고 모델을 만드는 것을 연습해보았습니다.\n단순한 몇가지 가정만으로도 우리는 피크에 다다르는 모델을 볼 수 있었습니다.\n그럼 이제 실제 데이터를 가지고 저 파라미터가 재생산지수와 어떤 관게가 있는지, 파라미터를 어떻게 알 수 있을지 다음 포스트로 알아보도록 하겠습니다.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}