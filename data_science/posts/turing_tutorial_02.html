<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.548">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-09-08">

<title>Practical Recipes for Data Science - 줄리아와 Turing.jl을 이용한 베이지안 통계 (2): 왜 줄리아를 사용하나요?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../images/siamese-cat.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Practical Recipes for Data Science</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/JunDamin"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">줄리아와 Turing.jl을 이용한 베이지안 통계 (2): 왜 줄리아를 사용하나요?</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 8, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="프로젝트-소개" class="level2">
<h2 class="anchored" data-anchor-id="프로젝트-소개">프로젝트 소개</h2>
<p><a href="https://storopoli.io/Bayesian-Julia/">Bayesian Statsitics using Julia and Turing</a>이라는 온라인 책이 있습니다.</p>
<p><a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 Internacional</a>라이센스를 고려하여 이 구조를 따라서 재구성을 해보고자 합니다.</p>
<p>개인적인 관심이 있어 시작하는 프로젝트로 총 13개의 파트로 구성될 예정입니다.</p>
<p>완전히 동일하게 진행하기 보다는 조금 설명을 덧붙이며 진행하도록 하겠습니다.</p>
</section>
<section id="줄리아-언어란" class="level2">
<h2 class="anchored" data-anchor-id="줄리아-언어란">줄리아 언어란?</h2>
<p>Julia(Bezanson, Edelman, Karpinski &amp; Shah, 2017)는 2012년에 처음 출시된 비교적 새로운 언어로, 고수준이면서도 빠른 것을 목표로 합니다. Julia는 LLVM을 사용하여 Just-in-time(JIT)으로 네이티브 코드로 컴파일되는 빠른 동적 유형 언어입니다. “C처럼 실행되지만 Python처럼 읽는다”라는 양쪽의 장점을 확보하고자 하는 언어 입니다. 퍄이썬처럼 매우 빠르게 프로토타입을 만들 수 있으며 코드가 파이썬처럼 읽고 쓰기 쉽습니다. 그러면서도 튜닝을 거치면 C와 유사한 속도를 낼 수 있어 점진적인 향상이 가능한 장점을 가지고 있습니다.<br>
명령형, 함수형, 객체 지향 프로그래밍의 기능을 결합한 다중 패러다임 언어입니다.</p>
</section>
<section id="julia는-왜-만들어-졌을까요" class="level2">
<h2 class="anchored" data-anchor-id="julia는-왜-만들어-졌을까요">Julia는 왜 만들어 졌을까요?</h2>
<p>Julia 창립자들이 쓴 꽤 오래된 이 글을 꼭 읽어보세요.</p>
<blockquote class="blockquote">
<p>우리는 Ruby의 역동성과 C의 속도를 원합니다. 우리는 Lisp와 같은 진정한 매크로와 Matlab과 같은 명확하고 친숙한 수학적 표기법을 가진 동형 언어를 원합니다. 우리는 Python만큼 일반 프로그래밍에 사용할 수 있고, R만큼 통계에 쉽게 사용할 수 있고, Perl만큼 문자열 처리에 자연스럽고, Matlab만큼 선형 대수에 강력하고, 쉘만큼 프로그램을 서로 붙이는 데 능숙한 것을 원합니다. 배우기 쉬운 것, 그러나 해커들을 만족시킬 수 있는 것. 우리는 인터랙티브하고 컴파일되는 언어를 원합니다.</p>
</blockquote>
</section>
<section id="왜-새로운-언어가-필요할까요" class="level2">
<h2 class="anchored" data-anchor-id="왜-새로운-언어가-필요할까요">왜 새로운 언어가 필요할까요?</h2>
<p>왜 새로운 언어가 필요할까요? 예를 들어 Python(또는 R)이 그렇게 빠르게 만들어질 수 없는 이유는 무엇일까요? Julia 매뉴얼 FAQ에 있는 공식 답변을 읽어 봅시다.</p>
<blockquote class="blockquote">
<p>기본적인 문제는 Julia의 컴파일러에 특별한 것이 없다는 것입니다. 우리는 다른 언어 개발자들이 모르는 “비밀 레시피”가 없는 일반적인 컴파일러(LLVM)를 사용합니다. Julia의 성능 이점은 거의 전적으로 프론트엔드에서 비롯됩니다. 언어 의미론은 잘 작성된 Julia 프로그램이 컴파일러에게 효율적인 코드와 메모리 레이아웃을 생성할 수 있는 더 많은 기회를 제공합니다. Matlab 또는 Python 코드를 Julia로 컴파일하려고 하면 Matlab 또는 Python의 의미론에 의해 컴파일러가 해당 언어에 대한 기존 컴파일러보다 더 나은 코드를 생성하지 못하거나(그리고 아마도 더 나쁠 수도 있습니다) 제한될 것입니다. Julia의 장점은 좋은 성능이 “내장” 유형 및 연산의 작은 부분에만 국한되지 않고 빠르고 메모리 효율적임에도 불구하고 임의의 사용자 정의 유형에서 작동하는 고수준 유형 일반 코드를 작성할 수 있다는 것입니다. Python과 같은 언어의 유형은 유사한 기능을 위해 컴파일러에 충분한 정보를 제공하지 않으므로 이러한 언어를 Julia 프론트엔드로 사용하면 막히게 됩니다.</p>
</blockquote>
<p>위의 설명은 Julia 커뮤니티의 “공식” 답변입니다. 제 관점에서 Julia는 과학적 컴퓨팅에서 사용하기에 중요한 세 가지 주요 기능을 가지고 있습니다.</p>
<ul>
<li>속도</li>
<li>사용 용이성</li>
<li>다중 디스패치</li>
</ul>
<p>이제 이 세 가지 기능 각각에 대해 자세히 알아보겠습니다.</p>
</section>
<section id="속도" class="level2">
<h2 class="anchored" data-anchor-id="속도">속도</h2>
<p>Julia는 빠릅니다. 그것도 매우 빠릅니다! 줄리아는 속도를 위해 만들어졌습니다. Julia는 LLVM 컴파일러를 사용하여 코드를 네이티브 코드로 변환합니다. R 또는 CPython을 사용하는 Python과 비교하면 데이터 과학 및 통계에서 다른 언어에 비해 Julia가 큰 속도 이점을 가지고 있는 이유 입니다. Julia는 LLVM의 컴파일러를 통해 코드를 최적화할 수 있습니다.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
벤치마킹
</div>
</div>
<div class="callout-body-container callout-body">
<p>함수 호출, 문자열 구문 분석, 정렬, 수치 루프, 난수 생성, 재귀 및 배열 연산과 같은 다양한 일반적인 코드 패턴에 대한 벤치마크를 Julia와 C, Rust, Go, JavaScript, R, Python, Fortran 및 Java와 같은 여러 다른 언어를 사용해 비교한 벤치마킹 기록이 있습니다. 아래 그림은 Julia의 웹사이트에서 가져온 것입니다. 이를 보면 Julia가 실제로 빠르다는 것을 알 수 있습니다. <img src="https://storopoli.io/Bayesian-Julia/pages/images/benchmarks.svg" class="img-fluid" alt="벤치마킹"></p>
</div>
</div>
<p>얼마나 Julia가 빠른지 보여주기 위해서 간단한 “groupby” 연산을 python, R, Julia로 테스트 해보겠습니다.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true">Julia Code</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false">python Code</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-3" role="tab" aria-controls="tabset-1-3" aria-selected="false">R Code</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<div id="a148e94a" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Random</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">StatsBase</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">DataFrames</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">BenchmarkTools</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Chain</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="bu">Random</span>.<span class="fu">seed!</span>(<span class="fl">123</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="fl">10_000</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> <span class="fu">DataFrame</span>(</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  x<span class="op">=</span><span class="fu">sample</span>([<span class="st">"A"</span>, <span class="st">"B"</span>, <span class="st">"C"</span>, <span class="st">"D"</span>], n, replace<span class="op">=</span><span class="cn">true</span>),</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  y<span class="op">=</span><span class="fu">rand</span>(n),</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  z<span class="op">=</span><span class="fu">randn</span>(n),</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="pp">@chain</span> <span class="op">$</span>df <span class="cf">begin</span> <span class="co"># passing 'df' as reference so the compiler cannot optimze</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">groupby</span>(<span class="op">:</span>x)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">combine</span>(<span class="op">:</span>y <span class="op">=&gt;</span> median, <span class="op">:</span>z <span class="op">=&gt;</span> mean)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<pre class="{python}"><code>import pandas as pd
import numpy as np

n = 10000

df = pd.DataFrame({'x': np.random.choice(["A", "B", "C", "D"],),
                   'y': np.random.randn(n),
                   'z': np.random.rand(n)})

%timeit df.groupby('x').agg({'y': 'median', 'z': 'mean'})</code></pre>
</div>
<div id="tabset-1-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-3-tab">
<pre class="{r}"><code>library(dplyr)

n &lt;- 10e3
df &lt;- tibble(
  x = sample(c("A", "B", "C", "D"), n, replace = TRUE),
  y = runif(n),
  z = rnorm(n),
)

bench::mark(
  df %&gt;%
      group_by(x) %&gt;%
      summarize(
        median(y),
        mean(z)
      )
)</code></pre>
</div>
</div>
</div>
</section>
<section id="사용-편이성" class="level2">
<h2 class="anchored" data-anchor-id="사용-편이성">사용 편이성</h2>
<p>가장 놀라운 점은 Julia가 매우 간단하고 이해하기 쉬운 구문을 가지고 있으면서도 C만큼 빠르고(일부 애플리케이션에서는 Java보다 빠름) 할 수 있다는 것입니다. 이 기능과 속도는 Julia 제작자가 “두 가지 언어 문제”라고 부르는 문제를 해결합니다.<br>
“두 가지 언어 문제”는 연구자 또는 컴퓨터 과학자가 쉽게 코딩할 수 있는 언어(예: Python)로 알고리즘 또는 솔루션을 프로토타입으로 만들어서 작동하면 코딩하기 쉽지 않은 빠른 언어(C 또는 FORTRAN)로 코딩하는 매우 전형적인 과학적 컴퓨팅 프로세스입니다. 프로토타입을 만들기 쉽지만 구현에는 적합하지 않은 언어(대부분 느리기 때문)와 코딩하기 쉽지 않은 언어(그리고 결과적으로 프로토타입을 만들기 쉽지 않은 언어)이지만 구현에는 적합한 언어(대부분 빠르기 때문)가 새로운 솔루션을 개발하는 과정에서 사용됩니다.</p>
<p>이것은 때로는 엄청난 비용으로 다가오게 되고 과학자와 기술자가 서로 다른 언어를 쓰게 되면서 과연 동일한 알고리즘을 잘 구현했는지 확인하기 어려운 문제도 발생하게 됩니다.</p>
<p>Julia는 프로토타입(사용 편의성이 중요)과 실제 구현(속도가 중요)을 동일한 언어로 진행할 수 있게 하여 이 문제를 해결하고자 합니다.</p>
<p>또한 Julia는 변수 또는 매개변수로 유니코드 문자를 사용할 수 있습니다. 이는 더 이상 sigma 또는 sigma_i를 사용하지 않고 대신 수학적 표기법에서와 같이 σ 또는 σᵢ을 사용할 수 있다는 뜻입니다. 알고리즘이나 수학 방정식의 표기를 코드와 같이 가져가서 코드와 수학 기호가 일대일 관계가 될 수 있습니다. 이것은 강력한 기능입니다.</p>
<p>“두 가지 언어 문제”와 일대일 코드 및 수학 관계는 Julia의 제작자 중 한 명인 Alan Edelman이 TED Talk에서 가장 잘 설명한 것 같습니다(아래 비디오 참조).</p>
<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/qGW0GT1rCvs" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
<p>책에서는 <a href="https://storopoli.io/Bayesian-Julia/pages/01_why_Julia/">Metropolis algorithm을 R, Python, C++를 사용해서 구현</a>하여 두 언어 문제를 어떻게 해소하는지 예시로 보여주고 있습니다. 다만 저는 잘 알지 못하는 부분이 많아서 여기서는 생략하고자 합니다. 더 알고 싶으신 분은 링크를 타고 가서 확인해 주세요.</p>
</section>
<section id="멀티플-디스패치" class="level2">
<h2 class="anchored" data-anchor-id="멀티플-디스패치">멀티플 디스패치</h2>
<p>저는 이것이 Julia 언어의 진정한 게임 체인저라고 생각합니다. 멀티플 디스패치란 인수의 타입에 따라서 함수가 다르게 적용될 수 있도록 정의할 수 있는 기능입니다. 멀티플 디스패치는 함수 또는 메서드가 런타임(동적) 타입 또는 더 일반적인 경우 하나 이상의 인수의 타입에 따라 동적으로 디스패치될 수 있는 기능입니다. 이것은 메서드가 호출된 객체의 타입에 따라 함수 또는 메서드 호출이 동적으로 디스패치되는 단일 디스패치 다형성의 일반화입니다. 멀티플 디스패치는 하나 이상의 인수의 결합된 특성을 사용하여 동적 디스패치를 구현하여 함수 또는 메서드로 라우팅합니다.</p>
<p>대부분의 언어는 호출할 메서드를 결정하기 위해 메서드의 첫 번째 매개변수에 의존하는 단일 디스패치 다형성을 가지고 있습니다. 하지만 Julia가 다른 점은 여러 매개변수가 고려된다는 것입니다. 이를 통해 동일한 초기 매개변수를 가지는 유사한 함수의 여러 정의가 가능합니다. 저는 이것이 Julia의 제작자 중 한 명인 Stefan Karpinski가 JuliaCon 2019에서 가장 잘 설명했다고 생각합니다(아래 비디오 참조):</p>
<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/kc9HwsxE1OY" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
<section id="멀티플-디스패치-따라해보기-개와-고양이" class="level3">
<h3 class="anchored" data-anchor-id="멀티플-디스패치-따라해보기-개와-고양이">멀티플 디스패치 따라해보기 : 개와 고양이</h3>
<p>Karpinski의 예시를 재현하겠습니다. 이 강연에서 Karpinski는 객체 지향 프로그래밍(OOP)에서 매우 일반적인 클래스의 구조를 설계합니다. Julia에서는 클래스가 없지만 “구조화된 데이터”를 의미하는 구조(<code>struct</code>)가 있습니다. <code>struct</code>는 변수만 갖지고 있는 클래스와 사실상 같습니다. 즉, 필드 세트(다른 언어에서는 “속성”이라고도 함)를 정의하면 됩니다. 그런 다음 구조에 의해 정의된 필드에 대한 고유한 특정 값을 가진 개별 인스턴스(또는 “객체”)를 생성할 수 있습니다.</p>
<p><code>Pet</code>이라는 추상 타입을 만듭니다. 그런 다음 <code>Pet</code>에서 하나의 필드 이름(<code>String</code>)을 가진 두 개의 파생 구조를 생성합니다. 이 파생 구조는 개와 고양이입니다. 또한 “만남”에서 발생하는 일에 대한 몇 가지 메서드를 정의합니다. 이는 Julia가 런타임에 다중 디스패치하여 한 유형의 <code>Pet</code>이 다른 <code>Pet</code>을 만날 때 취하는 동작을 정의하는 일반 함수 <code>meets()</code>와 <code>meets()</code>의 여러 특정 메서드를 정의합니다.</p>
<div id="f7898eb2" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 추상 타입을 정의</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">abstract type</span> Pet <span class="kw">end</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Dog 타입 정의</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Dog <span class="op">&lt;:</span><span class="dt"> Pet</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    name<span class="op">::</span><span class="dt">String</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Cat 타입 정의</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Cat <span class="op">&lt;:</span><span class="dt"> Pet</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    name<span class="op">::</span><span class="dt">String</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co"># 두 Pet 타입이 만났을 때 인터랙션을 정의</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">encounter</span>(a<span class="op">::</span><span class="dt">Pet</span>, b<span class="op">::</span><span class="dt">Pet</span>)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    verb <span class="op">=</span> <span class="fu">meets</span>(a, b)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">println</span>(<span class="st">"</span><span class="sc">$</span>(a.name)<span class="st"> meets </span><span class="sc">$</span>(b.name)<span class="st"> and </span><span class="sc">$</span>verb<span class="st">"</span>)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="co"># 각 타입별로 같은 이름의 함수를 정의</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="fu">meets</span>(a<span class="op">::</span><span class="dt">Dog</span>, b<span class="op">::</span><span class="dt">Dog</span>) <span class="op">=</span> <span class="st">"sniffs"</span>;</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="fu">meets</span>(a<span class="op">::</span><span class="dt">Dog</span>, b<span class="op">::</span><span class="dt">Cat</span>) <span class="op">=</span> <span class="st">"chases"</span>;</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="fu">meets</span>(a<span class="op">::</span><span class="dt">Cat</span>, b<span class="op">::</span><span class="dt">Dog</span>) <span class="op">=</span> <span class="st">"hisses"</span>;</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a><span class="fu">meets</span>(a<span class="op">::</span><span class="dt">Cat</span>, b<span class="op">::</span><span class="dt">Cat</span>) <span class="op">=</span> <span class="st">"slinks"</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>이제 객체를 생성하고 Julia에서 만나게(<code>encounter</code>)했을 때를 살펴 봅시다.</p>
<div id="0d470902" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>fido <span class="op">=</span> <span class="fu">Dog</span>(<span class="st">"Fido"</span>);</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>rex <span class="op">=</span> <span class="fu">Dog</span>(<span class="st">"Rex"</span>);</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>whiskers <span class="op">=</span> <span class="fu">Cat</span>(<span class="st">"Whiskers"</span>);</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>spots <span class="op">=</span> <span class="fu">Cat</span>(<span class="st">"Spots"</span>);</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="fu">encounter</span>(fido, rex)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="fu">encounter</span>(rex, whiskers)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="fu">encounter</span>(spots, fido)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="fu">encounter</span>(whiskers, spots)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="예시-원-핫-벡터" class="level3">
<h3 class="anchored" data-anchor-id="예시-원-핫-벡터">예시: 원-핫 벡터</h3>
<p>또 다른 좋은 예로 one-hot 벡터로 변환해 보겠습니다. 원-핫 벡터는 단 하나의 값을 제외한 모든 값이 0(0)인 정수 벡터를 의미합니다. 머신 러닝에서 one-hot 인코딩은 범주형 데이터를 처리하는 데 자주 사용되는 방법입니다. 많은 머신 러닝 모델은 입력 변수를 숫자로 변환해야 하기 때문에 범주형 변수를 one-hot 인코딩(변환)을 해야 합니다. 아래 예제는 <a href="https://habr.com/ru/post/468609/">Vasily Pisarev의 게시물</a>에서 크게 영감을 받았습니다.</p>
<p>Julia에서 원-핫 벡터를 어떻게 표현할까요? 간단합니다. <code>struct</code> 키워드를 사용하여 Julia에 <code>OneHotVector</code>를 새로운 타입으로 만들고 <code>OneHotVector</code> 길이와 인덱스를 나타내는 두 필드 <code>len</code>과 <code>ind</code>를 정의합니다. 그런 다음 새로 정의된 <code>OneHotVector</code>에 대한 <code>Base</code> 함수 <code>size()</code> 및 <code>getindex()</code>에 대한 새로운 메서드를 정의합니다.</p>
<div id="f619fff5" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> <span class="bu">Base</span>: size, getindex</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> OneHotVector <span class="op">&lt;:</span><span class="dt"> AbstractVector{Int}</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    len<span class="op">::</span><span class="dt">Int</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    ind<span class="op">::</span><span class="dt">Int</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="fu">size</span>(v<span class="op">::</span><span class="dt">OneHotVector</span>) <span class="op">=</span> (v.len,)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="fu">getindex</span>(v<span class="op">::</span><span class="dt">OneHotVector</span>, i<span class="op">::</span><span class="dt">Integer</span>) <span class="op">=</span> <span class="fu">Int</span>(i <span class="op">==</span> v.ind)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>OneHotVector</code>가 <code>AbstractVector</code>의 하위 범주에 속하는 <code>struct</code>이기 때문에, 우리는 <code>AbstractVector</code>에서 정의된 모든 메소드를 사용할 수 있습니다. <code>Array</code>의 리스트 컴프리헨션을 아래와 같이 사용할 수 있습니다.</p>
<div id="a9b8600d" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>onehot <span class="op">=</span> [<span class="fu">OneHotVector</span>(<span class="fl">3</span>, <span class="fu">rand</span>(<span class="fl">1</span><span class="op">:</span><span class="fl">3</span>)) for _ <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">4</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>이제 내적의 합을 나타내는 새로운 함수 <code>inner_sum()</code>을 정의합니다. 여기서 <code>A</code>는 행렬 같은 것입니다(비록 제가 유형을 나타내지 않았지만 이름만으로 무언가를 추측할 수 있습니다). 그리고 <code>vs</code>는 일부 벡터와 같은 요소의 벡터입니다. 이 함수는 “행렬”의 내적을 <code>vs</code>의 모든 벡터와 같은 요소와 취하여 누적된 값을 반환합니다. 이것은 모든 유형을 지정하지 않고 주어진 일반적인 정의입니다. 여기서 일반 프로그래밍은 루프에서 이 함수 호출 <code>inner()</code>로 구성됩니다.</p>
<div id="dc295d6c" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">LinearAlgebra</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">inner_sum</span>(A, vs)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> <span class="fu">zero</span>(<span class="fu">eltype</span>(A))</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> vs</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        t <span class="op">+=</span> <span class="fu">inner</span>(v, A, v) <span class="co"># multiple dispatch!</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> t</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="fu">inner</span>(v, A, w) <span class="op">=</span> <span class="fu">dot</span>(v, A <span class="op">*</span> w) <span class="co"># very general definition</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>이제 시험해 봅니다.</p>
<div id="14d64938" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> <span class="fu">rand</span>(<span class="fl">3</span>, <span class="fl">3</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>vs <span class="op">=</span> [<span class="fu">rand</span>(<span class="fl">3</span>) for _ <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">4</span>]</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="fu">inner_sum</span>(A, vs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>OneHotVector</code>는 <code>AbstractVector</code>의 하위 타입이기 때문에 우리는 <code>innter_sum</code>을 사용할 수 있습니다.</p>
<div id="babe3be5" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">supertype</span>(OneHotVector)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="c6d69d04" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">inner_sum</span>(A, onehot)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>하지만 이렇게 정의하는 방식은 다소 느립니다.</p>
<div id="d942fcbe" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">BenchmarkTools</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">inner_sum</span>(<span class="op">$</span>A, <span class="op">$</span>onehot)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>우리는 이 절차를 상당히 최적화 할 수 있습니다. 자 <code>OneHotVector</code>에 의한 행렬 곱을 단순한 컬럼 선택으로 재정의 해봅시다. 우리는 Julia <code>Base</code>의 <code>*</code>함수의 새로운 메소드를 정의함으로 이를 할 수 있습니다.</p>
<div id="ea5caac7" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> <span class="bu">Base</span>: *</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="fu">*</span>(A<span class="op">::</span><span class="dt">AbstractMatrix</span>, v<span class="op">::</span><span class="dt">OneHotVector</span>) <span class="op">=</span> A[<span class="op">:</span>, v.ind]</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="fu">inner</span>(v<span class="op">::</span><span class="dt">OneHotVector</span>, A, w<span class="op">::</span><span class="dt">OneHotVector</span>) <span class="op">=</span> A[v.ind, w.ind]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>이게 다입니다. 아주 간단하죠? 그럼 벤치마킹을 해봅시다.</p>
<div id="778340e7" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="pp">@btime</span> <span class="fu">inner_sum</span>(<span class="op">$</span>A, <span class="op">$</span>onehot)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>엄청난 속도 향상입니다!🚀</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>