{
  "hash": "d0ed727a51b4d8f469acb35a12f941fb",
  "result": {
    "markdown": "---\ntitle: '줄리아와 Turing.jl을 이용한 베이지안 통계 (2): 왜 줄리아를 사용하나요?'\ndate: '2023-09-08'\ncagetory:\n  - julia\n  - Turing.jl\n  - tutorial\n  - bayesian statistics\noutput: true\nwarning: false\ncode-fold: true\n---\n\n## 프로젝트 소개\n\n[Bayesian Statsitics using Julia and Turing](https://storopoli.io/Bayesian-Julia/)이라는 온라인 책이 있습니다. \n\n[Creative Commons Attribution-ShareAlike 4.0 Internacional](http://creativecommons.org/licenses/by-sa/4.0/)라이센스를 고려하여 이 구조를 따라서 재구성을 해보고자 합니다.\n\n개인적인 관심이 있어 시작하는 프로젝트로 총 13개의 파트로 구성될 예정입니다.\n\n완전히 동일하게 진행하기 보다는 조금 설명을 덧붙이며 진행하도록 하겠습니다. \n\n## 줄리아 언어란?\n\nJulia(Bezanson, Edelman, Karpinski & Shah, 2017)는 2012년에 처음 출시된 비교적 새로운 언어로, 고수준이면서도 빠른 것을 목표로 합니다. \nJulia는 LLVM을 사용하여 Just-in-time(JIT)으로 네이티브 코드로 컴파일되는 빠른 동적 유형 언어입니다.\n\"C처럼 실행되지만 Python처럼 읽는다\"라는 양쪽의 장점을 확보하고자 하는 언어 입니다. \n퍄이썬처럼 매우 빠르게 프로토타입을 만들 수 있으며 코드가 파이썬처럼 읽고 쓰기 쉽습니다.\n그러면서도 튜닝을 거치면 C와 유사한 속도를 낼 수 있어 점진적인 향상이 가능한 장점을 가지고 있습니다.  \n명령형, 함수형, 객체 지향 프로그래밍의 기능을 결합한 다중 패러다임 언어입니다.\n\n\n## Julia는 왜 만들어 졌을까요?\n\nJulia 창립자들이 쓴 꽤 오래된 이 글을 꼭 읽어보세요.\n\n> 우리는 Ruby의 역동성과 C의 속도를 원합니다. 우리는 Lisp와 같은 진정한 매크로와 Matlab과 같은 명확하고 친숙한 수학적 표기법을 가진 동형 언어를 원합니다. 우리는 Python만큼 일반 프로그래밍에 사용할 수 있고, R만큼 통계에 쉽게 사용할 수 있고, Perl만큼 문자열 처리에 자연스럽고, Matlab만큼 선형 대수에 강력하고, 쉘만큼 프로그램을 서로 붙이는 데 능숙한 것을 원합니다. 배우기 쉬운 것, 그러나 해커들을 만족시킬 수 있는 것. 우리는 인터랙티브하고 컴파일되는 언어를 원합니다.\n\n## 왜 새로운 언어가 필요할까요?\n\n왜 새로운 언어가 필요할까요? 예를 들어 Python(또는 R)이 그렇게 빠르게 만들어질 수 없는 이유는 무엇일까요? Julia 매뉴얼 FAQ에 있는 공식 답변을 읽어 봅시다.\n\n> 기본적인 문제는 Julia의 컴파일러에 특별한 것이 없다는 것입니다. 우리는 다른 언어 개발자들이 모르는 \"비밀 레시피\"가 없는 일반적인 컴파일러(LLVM)를 사용합니다. Julia의 성능 이점은 거의 전적으로 프론트엔드에서 비롯됩니다. 언어 의미론은 잘 작성된 Julia 프로그램이 컴파일러에게 효율적인 코드와 메모리 레이아웃을 생성할 수 있는 더 많은 기회를 제공합니다. Matlab 또는 Python 코드를 Julia로 컴파일하려고 하면 Matlab 또는 Python의 의미론에 의해 컴파일러가 해당 언어에 대한 기존 컴파일러보다 더 나은 코드를 생성하지 못하거나(그리고 아마도 더 나쁠 수도 있습니다) 제한될 것입니다. Julia의 장점은 좋은 성능이 \"내장\" 유형 및 연산의 작은 부분에만 국한되지 않고 빠르고 메모리 효율적임에도 불구하고 임의의 사용자 정의 유형에서 작동하는 고수준 유형 일반 코드를 작성할 수 있다는 것입니다. Python과 같은 언어의 유형은 유사한 기능을 위해 컴파일러에 충분한 정보를 제공하지 않으므로 이러한 언어를 Julia 프론트엔드로 사용하면 막히게 됩니다.\n\n위의 설명은 Julia 커뮤니티의 \"공식\" 답변입니다. \n제 관점에서 Julia는 과학적 컴퓨팅에서 사용하기에 중요한 세 가지 주요 기능을 가지고 있습니다.\n\n- 속도\n- 사용 용이성\n- 다중 디스패치\n\n이제 이 세 가지 기능 각각에 대해 자세히 알아보겠습니다.\n\n## 속도\n\nJulia는 빠릅니다. 그것도 매우 빠릅니다! 줄리아는 속도를 위해 만들어졌습니다. Julia는 LLVM 컴파일러를 사용하여 코드를 네이티브 코드로 변환합니다. R 또는 CPython을 사용하는 Python과 비교하면 데이터 과학 및 통계에서 다른 언어에 비해 Julia가 큰 속도 이점을 가지고 있는 이유 입니다. Julia는 LLVM의 컴파일러를 통해 코드를 최적화할 수 있습니다.\n\n:::{.callout-tip}\n## 벤치마킹\n함수 호출, 문자열 구문 분석, 정렬, 수치 루프, 난수 생성, 재귀 및 배열 연산과 같은 다양한 일반적인 코드 패턴에 대한 벤치마크를 Julia와 C, Rust, Go, JavaScript, R, Python, Fortran 및 Java와 같은 여러 다른 언어를 사용해 비교한 벤치마킹 기록이 있습니다. 아래 그림은 Julia의 웹사이트에서 가져온 것입니다. 이를 보면 Julia가 실제로 빠르다는 것을 알 수 있습니다.\n![벤치마킹](https://storopoli.io/Bayesian-Julia/pages/images/benchmarks.svg)\n:::\n\n얼마나 Julia가 빠른지 보여주기 위해서 간단한 \"groupby\" 연산을 python, R, Julia로 테스트 해보겠습니다.\n\n:::{.panel-tabset}\n\n## Julia Code \n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Random\nusing StatsBase\nusing DataFrames\nusing BenchmarkTools\nusing Chain\nRandom.seed!(123)\n\nn = 10_000\n\ndf = DataFrame(\n  x=sample([\"A\", \"B\", \"C\", \"D\"], n, replace=true),\n  y=rand(n),\n  z=randn(n),\n)\n@btime @chain $df begin # passing 'df' as reference so the compiler cannot optimze\n  groupby(:x)\n  combine(:y => median, :z => mean)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  309.000 μs (434 allocations: 541.09 KiB)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div><div style = \"float: left;\"><span>4×3 DataFrame</span></div><div style = \"clear: both;\"></div></div><div class = \"data-frame\" style = \"overflow-x: scroll;\"><table class = \"data-frame\" style = \"margin-bottom: 6px;\"><thead><tr class = \"header\"><th class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">Row</th><th style = \"text-align: left;\">x</th><th style = \"text-align: left;\">y_median</th><th style = \"text-align: left;\">z_mean</th></tr><tr class = \"subheader headerLastRow\"><th class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\"></th><th title = \"String\" style = \"text-align: left;\">String</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th></tr></thead><tbody><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">1</td><td style = \"text-align: left;\">C</td><td style = \"text-align: right;\">0.504698</td><td style = \"text-align: right;\">0.0225328</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">2</td><td style = \"text-align: left;\">D</td><td style = \"text-align: right;\">0.501997</td><td style = \"text-align: right;\">0.0203876</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">3</td><td style = \"text-align: left;\">A</td><td style = \"text-align: right;\">0.507449</td><td style = \"text-align: right;\">-0.00726282</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">4</td><td style = \"text-align: left;\">B</td><td style = \"text-align: right;\">0.486637</td><td style = \"text-align: right;\">-0.0449718</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n## python Code\n\n\n```{python}\nimport pandas as pd\nimport numpy as np\n\nn = 10000\n\ndf = pd.DataFrame({'x': np.random.choice([\"A\", \"B\", \"C\", \"D\"],),\n                   'y': np.random.randn(n),\n                   'z': np.random.rand(n)})\n\n%timeit df.groupby('x').agg({'y': 'median', 'z': 'mean'})\n```\n\n\n\n## R Code\n\n\n```{r}\nlibrary(dplyr)\n\nn <- 10e3\ndf <- tibble(\n  x = sample(c(\"A\", \"B\", \"C\", \"D\"), n, replace = TRUE),\n  y = runif(n),\n  z = rnorm(n),\n)\n\nbench::mark(\n  df %>%\n      group_by(x) %>%\n      summarize(\n        median(y),\n        mean(z)\n      )\n)\n```\n\n\n:::\n\n## 사용 편이성\n\n가장 놀라운 점은 Julia가 매우 간단하고 이해하기 쉬운 구문을 가지고 있으면서도 C만큼 빠르고(일부 애플리케이션에서는 Java보다 빠름) 할 수 있다는 것입니다. \n이 기능과 속도는 Julia 제작자가 \"두 가지 언어 문제\"라고 부르는 문제를 해결합니다.  \n\"두 가지 언어 문제\"는 연구자 또는 컴퓨터 과학자가 쉽게 코딩할 수 있는 언어(예: Python)로 알고리즘 또는 솔루션을 프로토타입으로 만들어서 작동하면 코딩하기 쉽지 않은 빠른 언어(C 또는 FORTRAN)로 코딩하는 매우 전형적인 과학적 컴퓨팅 프로세스입니다. \n프로토타입을 만들기 쉽지만 구현에는 적합하지 않은 언어(대부분 느리기 때문)와 코딩하기 쉽지 않은 언어(그리고 결과적으로 프로토타입을 만들기 쉽지 않은 언어)이지만 구현에는 적합한 언어(대부분 빠르기 때문)가 새로운 솔루션을 개발하는 과정에서 사용됩니다.\n\n이것은 때로는 엄청난 비용으로 다가오게 되고 과학자와 기술자가 서로 다른 언어를 쓰게 되면서 과연 동일한 알고리즘을 잘 구현했는지 확인하기 어려운 문제도 발생하게 됩니다.\n\nJulia는 프로토타입(사용 편의성이 중요)과 실제 구현(속도가 중요)을 동일한 언어로 진행할 수 있게 하여 이 문제를 해결하고자 합니다.\n\n또한 Julia는 변수 또는 매개변수로 유니코드 문자를 사용할 수 있습니다. \n이는 더 이상 sigma 또는 sigma_i를 사용하지 않고 대신 수학적 표기법에서와 같이 σ 또는 σᵢ을 사용할 수 있다는 뜻입니다. 알고리즘이나 수학 방정식의 표기를 코드와 같이 가져가서 코드와 수학 기호가 일대일 관계가 될 수 있습니다. 이것은 강력한 기능입니다.\n\n\"두 가지 언어 문제\"와 일대일 코드 및 수학 관계는 Julia의 제작자 중 한 명인 Alan Edelman이 TED Talk에서 가장 잘 설명한 것 같습니다(아래 비디오 참조).\n\n\n{{< video https://youtu.be/qGW0GT1rCvs >}}\n\n\n\n책에서는 [Metropolis algorithm을 R, Python, C++를 사용해서 구현](https://storopoli.io/Bayesian-Julia/pages/01_why_Julia/)하여 두 언어 문제를 어떻게 해소하는지 예시로 보여주고 있습니다. \n다만 저는 잘 알지 못하는 부분이 많아서 여기서는 생략하고자 합니다. 더 알고 싶으신 분은 링크를 타고 가서 확인해 주세요.\n\n## 멀티플 디스패치\n\n저는 이것이 Julia 언어의 진정한 게임 체인저라고 생각합니다. \n멀티플 디스패치란 인수의 타입에 따라서 함수가 다르게 적용될 수 있도록 정의할 수 있는 기능입니다. \n멀티플 디스패치는 함수 또는 메서드가 런타임(동적) 타입 또는 더 일반적인 경우 하나 이상의 인수의 타입에 따라 동적으로 디스패치될 수 있는 기능입니다. \n이것은 메서드가 호출된 객체의 타입에 따라 함수 또는 메서드 호출이 동적으로 디스패치되는 단일 디스패치 다형성의 일반화입니다. \n멀티플 디스패치는 하나 이상의 인수의 결합된 특성을 사용하여 동적 디스패치를 구현하여 함수 또는 메서드로 라우팅합니다.\n\n대부분의 언어는 호출할 메서드를 결정하기 위해 메서드의 첫 번째 매개변수에 의존하는 단일 디스패치 다형성을 가지고 있습니다. \n하지만 Julia가 다른 점은 여러 매개변수가 고려된다는 것입니다. \n이를 통해 동일한 초기 매개변수를 가지는 유사한 함수의 여러 정의가 가능합니다. \n저는 이것이 Julia의 제작자 중 한 명인 Stefan Karpinski가 JuliaCon 2019에서 가장 잘 설명했다고 생각합니다(아래 비디오 참조):\n\n\n{{< video  https://youtu.be/kc9HwsxE1OY >}}\n\n",
    "supporting": [
      "turing_tutorial_02_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}