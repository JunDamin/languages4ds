{
  "hash": "e758e0a5f2c4469664d3d808d44a68fe",
  "result": {
    "markdown": "---\ntitle: Tutorial of Algebra of Graphics\ndate: '2023-05-11'\ncagetory:\n  - julia\n  - visualization\n  - tutorial\noutput: true\nwarning: false\ncode-fold: true\nimage: penguins.png\n---\n\n줄리아 언어에 그래픽 옵션 중 Makie(마키에)라는 패키지가 있습니다. \n파이썬의 matplotlib과 같이 그래픽 엔진과 같은 기능을 가지고 있습니다.\n\nmatplotlib에는 seaborn이 있듯이 Makie에는 Algebra of Graphics라는 패키지가 있습니다.\n주로 사용하는 기능을 쉽게 만들 수 있는 기능인데요. grammar of graphics의 영향을 받은 R의 ggplot2와 유사한 기능이 있습니다.\n\n오늘은 그 [튜토리얼](https://aog.makie.org/stable/generated/penguins/)을 같이 살펴 보도록 하겠습니다.\n\n## 팽귄 데이터 셋\n\n오늘 시각화할 데이터 셋은 팽귄 데이터 셋입니다. \n팽귄 333마리에 대한 관측자료입니다.\n종, 서식지, 부리(bill) 길이, 부리 깊이, 날개(flipper) 길이, 몸무게, 성별 정보를 가지고 있습니다. \n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing PalmerPenguins, DataFrames, CSV\n\npenguins = dropmissing(DataFrame(PalmerPenguins.load()))\nfirst(penguins, 6)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div><div style = \"float: left;\"><span>6×7 DataFrame</span></div><div style = \"clear: both;\"></div></div><div class = \"data-frame\" style = \"overflow-x: scroll;\"><table class = \"data-frame\" style = \"margin-bottom: 6px;\"><thead><tr class = \"header\"><th class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">Row</th><th style = \"text-align: left;\">species</th><th style = \"text-align: left;\">island</th><th style = \"text-align: left;\">bill_length_mm</th><th style = \"text-align: left;\">bill_depth_mm</th><th style = \"text-align: left;\">flipper_length_mm</th><th style = \"text-align: left;\">body_mass_g</th><th style = \"text-align: left;\">sex</th></tr><tr class = \"subheader headerLastRow\"><th class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\"></th><th title = \"String15\" style = \"text-align: left;\">String15</th><th title = \"String15\" style = \"text-align: left;\">String15</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th><th title = \"Int64\" style = \"text-align: left;\">Int64</th><th title = \"Int64\" style = \"text-align: left;\">Int64</th><th title = \"String7\" style = \"text-align: left;\">String7</th></tr></thead><tbody><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">1</td><td style = \"text-align: left;\">Adelie</td><td style = \"text-align: left;\">Torgersen</td><td style = \"text-align: right;\">39.1</td><td style = \"text-align: right;\">18.7</td><td style = \"text-align: right;\">181</td><td style = \"text-align: right;\">3750</td><td style = \"text-align: left;\">male</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">2</td><td style = \"text-align: left;\">Adelie</td><td style = \"text-align: left;\">Torgersen</td><td style = \"text-align: right;\">39.5</td><td style = \"text-align: right;\">17.4</td><td style = \"text-align: right;\">186</td><td style = \"text-align: right;\">3800</td><td style = \"text-align: left;\">female</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">3</td><td style = \"text-align: left;\">Adelie</td><td style = \"text-align: left;\">Torgersen</td><td style = \"text-align: right;\">40.3</td><td style = \"text-align: right;\">18.0</td><td style = \"text-align: right;\">195</td><td style = \"text-align: right;\">3250</td><td style = \"text-align: left;\">female</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">4</td><td style = \"text-align: left;\">Adelie</td><td style = \"text-align: left;\">Torgersen</td><td style = \"text-align: right;\">36.7</td><td style = \"text-align: right;\">19.3</td><td style = \"text-align: right;\">193</td><td style = \"text-align: right;\">3450</td><td style = \"text-align: left;\">female</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">5</td><td style = \"text-align: left;\">Adelie</td><td style = \"text-align: left;\">Torgersen</td><td style = \"text-align: right;\">39.3</td><td style = \"text-align: right;\">20.6</td><td style = \"text-align: right;\">190</td><td style = \"text-align: right;\">3650</td><td style = \"text-align: left;\">male</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">6</td><td style = \"text-align: left;\">Adelie</td><td style = \"text-align: left;\">Torgersen</td><td style = \"text-align: right;\">38.9</td><td style = \"text-align: right;\">17.8</td><td style = \"text-align: right;\">181</td><td style = \"text-align: right;\">3625</td><td style = \"text-align: left;\">female</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n## 숫자 세기\n\n팽귄 수를 세어 봅니다. \nAoG(Algebra of Graphics)는 * 기호는 적용을, +는 붙이는 기능을 합니다.\n`data()` 함수로 데이터를 가져오고, `frequency()`는 숫자를 셉니다.\n`mapping()`함수는 어떤 기준으로 숫자를 셀지 결정합니다.\n\n마지막으로 `draw` 함수를 통해 출력 합니다.\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing AlgebraOfGraphics, CairoMakie\nset_aog_theme!()\n\naxis = (width = 225, height = 225)\npenguin_frequency = data(penguins) * frequency() * mapping(:species)\n\ndraw(penguin_frequency; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n![](index_files/figure-html/cell-3-output-1.svg){}\n:::\n:::\n\n\n### 색 지정 \n\n여기에 색깔을 지정해 봅니다.\n기존에 만든 그래프 `penguin_frequency`에 새로운 항목을 `mapping` 함수를 통해 적용합니다. \n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nplt = penguin_frequency * mapping(color = :island)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n![](index_files/figure-html/cell-4-output-1.svg){}\n:::\n:::\n\n\n### 규칙\n\n덧셈과 곱셈 규칙을 지킵니다. \n\ndodge argument를 통해 병렬로 제시할 수 있습니다.\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nplt = penguin_frequency * mapping(color = :island, dodge = :island)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n![](index_files/figure-html/cell-5-output-1.svg){}\n:::\n:::\n\n\n유사하게 `sex`로 구분할 수도 있습니다.\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nplt = penguin_frequency * mapping(color = :island, dodge = :sex)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n![](index_files/figure-html/cell-6-output-1.svg){}\n:::\n:::\n\n\n`stack`을 지정하면 누적그래프를 볼 수 있습니다. \n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nplt = penguin_frequency * mapping(color = :island, stack = :island)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n![](index_files/figure-html/cell-7-output-1.svg){}\n:::\n:::\n\n\n`dodge`와 같이 쓰이면 다음과 같습니다.\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nplt = penguin_frequency * mapping(color = :island, stack = :island, dodge=:sex)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n![](index_files/figure-html/cell-8-output-1.svg){}\n:::\n:::\n\n\nscatter plot은 아래와 같이 만들 수 있습니다.\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\npenguin_bill = data(penguins) * mapping(:bill_length_mm,:bill_depth_mm)\ndraw(penguin_bill; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n![](index_files/figure-html/cell-9-output-1.svg){}\n:::\n:::\n\n\n함수를 통해 변환하고 이름을 반영할 수도 있습니다. \n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\npenguin_bill = data(penguins) * mapping(\n    :bill_length_mm => (t -> t / 10) => \"bill length (cm)\",\n    :bill_depth_mm => (t -> t / 10) => \"bill depth (cm)\",\n)\ndraw(penguin_bill; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n![](index_files/figure-html/cell-10-output-1.svg){}\n:::\n:::\n\n\n부리 길이와 깊이에 대한 플롯에 색을 매칭할 수 있습니다.\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nplt = penguin_bill * mapping(color = :species)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n![](index_files/figure-html/cell-11-output-1.svg){}\n:::\n:::\n\n\n선형 회귀를 적용하여 그래픽을 적용할 수 있습니다.\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nplt = penguin_bill * linear() * mapping(color = :species)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n![](index_files/figure-html/cell-12-output-1.svg){}\n:::\n:::\n\n\n`+`를 통해 두 그래프를 곂쳐서 출력 할 수 있습니다. \n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nplt = penguin_bill * linear() * mapping(color = :species) + penguin_bill * mapping(color = :species)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n![](index_files/figure-html/cell-13-output-1.svg){}\n:::\n:::\n\n\n괄호를 써서 다소 긴 코드를 줄일 수 있습니다. \n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nplt = penguin_bill * (linear() + mapping()) * mapping(color = :species)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n![](index_files/figure-html/cell-14-output-1.svg){}\n:::\n:::\n\n\n또한 아래와 같이 리팩토링도 가능합니다.\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nlayers = linear() + mapping()\nplt = penguin_bill * layers * mapping(color = :species)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n![](index_files/figure-html/cell-15-output-1.svg){}\n:::\n:::\n\n\n마커를 지정하여 구분할 수 있습니다.\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\nlayers = linear() + mapping(marker = :sex)\nplt = penguin_bill * layers * mapping(color = :species)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n![](index_files/figure-html/cell-16-output-1.svg){}\n:::\n:::\n\n\n또는 컬럼을 지정할 수도 있습니다.\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nlayers = linear() + mapping(col = :sex)\nplt = penguin_bill * layers * mapping(color = :species)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n![](index_files/figure-html/cell-17-output-1.svg){}\n:::\n:::\n\n\n위의 그래프는 같은 피팅 선형 그래프를 보여주고 있습니다.\n데이터와 맞춰서 보여주길 원한다면 아래와 같이 하면 됩니다.\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nlayers = linear() + mapping()\nplt = penguin_bill * layers * mapping(color = :species, col = :sex)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n![](index_files/figure-html/cell-18-output-1.svg){}\n:::\n:::\n\n\n## Density plot\n\n밀도 플롯을 그려서 표현 할 수 있습니다.\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\nusing AlgebraOfGraphics: density\nplt = penguin_bill * density(npoints=50) * mapping(col = :species)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n![](index_files/figure-html/cell-19-output-1.svg){}\n:::\n:::\n\n\n`visual` 함수를 통해 시각적 효과를 지정할 수 있습니다.\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\nplt *= visual(colormap = :grayC, colorrange = (0, 6))\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n![](index_files/figure-html/cell-20-output-1.svg){}\n:::\n:::\n\n\n`Wireframe`을 지정하여 3D 그래프로 표현할 수 있습니다.\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\naxis = (type = Axis3, width = 300, height = 300)\nlayer = density() * visual(Wireframe, linewidth=0.05)\nplt = penguin_bill * layer * mapping(color = :species)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n![](index_files/figure-html/cell-21-output-1.svg){}\n:::\n:::\n\n\n`Contour`를 구할 수도 있습니다.\n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\naxis = (width = 225, height = 225)\nlayer = density() * visual(Contour)\nplt = penguin_bill * layer * mapping(color = :species)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n![](index_files/figure-html/cell-22-output-1.svg){}\n:::\n:::\n\n\n위에 내용을 합쳐서 아래와 같이 그릴 수도 있습니다.\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\nlayers = density() * visual(Contour) + linear() + mapping()\nplt = penguin_bill * layers * mapping(color = :species)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n![](index_files/figure-html/cell-23-output-1.svg){}\n:::\n:::\n\n\n`mapping`대신 `visual` 을 사용하여 특성을 지정할 수 도 있습니다.\n\n::: {.cell execution_count=23}\n``` {.julia .cell-code}\nlayers = density() * visual(Contour) + linear() + visual(alpha = 0.5)\nplt = penguin_bill * layers * mapping(color = :species)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n![](index_files/figure-html/cell-24-output-1.svg){}\n:::\n:::\n\n\n색을 사용해서 3개 변수를 표현하기 할 수 있습니다.\n\n::: {.cell execution_count=24}\n``` {.julia .cell-code}\nbody_mass = :body_mass_g => (t -> t / 1000) => \"body mass (kg)\"\nlayers = linear() * mapping(group = :species) + mapping(color = body_mass, marker = :species)\nplt = penguin_bill * layers\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n![](index_files/figure-html/cell-25-output-1.svg){}\n:::\n:::\n\n\n혹은 축을 지정하여 3차원으로 표현할 수도 있습니다.\n\n::: {.cell execution_count=25}\n``` {.julia .cell-code}\naxis = (type = Axis3, width = 300, height = 300)\nplt = penguin_bill * mapping(body_mass, color = :species)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n![](index_files/figure-html/cell-26-output-1.svg){}\n:::\n:::\n\n\n레이아웃을 지정하여 구분하여 표현도 가능합니다.\n\n::: {.cell execution_count=26}\n``` {.julia .cell-code}\nplt = penguin_bill * mapping(body_mass, color = :species, layout = :sex)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n![](index_files/figure-html/cell-27-output-1.svg){}\n:::\n:::\n\n\n## 머신러닝과 같이 사용하기\n\n간단히 Decision Tree 모델을 만들어 봅니다.\n\n::: {.cell execution_count=27}\n``` {.julia .cell-code}\nusing DecisionTree, Random\n\n# use approximately 80% of penguins for training\nRandom.seed!(1234) # for reproducibility\nN = nrow(penguins)\ntrain = fill(false, N)\nperm = randperm(N)\ntrain_idxs = perm[1:floor(Int, 0.8N)]\ntrain[train_idxs] .= true\n\n# fit model on training data and make predictions on the whole dataset\nX = hcat(penguins.bill_length_mm, penguins.bill_depth_mm)\ny = penguins.species\nmodel = DecisionTreeClassifier() # Support-Vector Machine Classifier\nfit!(model, X[train, :], y[train])\nŷ = predict(model, X)\n\n# incorporate relevant information in the dataset\npenguins.train = train;\npenguins.predicted_species = ŷ;\n\n\nCSV.write(\"penguins.csv\", penguins)\n```\n:::\n\n\n결과를 보면 `Chinstrap`종에 대해서 정확도가 낮음을 볼 수 있습니다.\n\n::: {.cell execution_count=28}\n``` {.julia .cell-code}\npenguins = CSV.read(\"penguins.csv\", DataFrame)\npenguin_bill = data(penguins) * mapping(:bill_length_mm,:bill_depth_mm)\n\naxis = (width = 225, height = 225)\ndataset =:train => renamer(true => \"training\", false => \"testing\") => \"Dataset\"\naccuracy = (:species, :predicted_species) => isequal => \"accuracy\"\nplt = data(penguins) *\n    expectation() *\n    mapping(:species, accuracy) *\n    mapping(col = dataset)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n![](index_files/figure-html/cell-29-output-1.svg){}\n:::\n:::\n\n\n에러율은 아래와 같이 볼 수 있습니다.\n\n::: {.cell execution_count=29}\n``` {.julia .cell-code}\nerror_rate = (:species, :predicted_species) => !isequal => \"error rate\"\nplt = data(penguins) *\n    expectation() *\n    mapping(:species, error_rate) *\n    mapping(col = dataset)\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n![](index_files/figure-html/cell-30-output-1.svg){}\n:::\n:::\n\n\n테스트와 트레이닝 기준으로 아래와 같이 분포를 볼 수 있습니다. \n\n::: {.cell execution_count=30}\n``` {.julia .cell-code}\nprediction = :predicted_species => \"predicted species\"\ndatalayer = mapping(color = prediction, row = :species, col = dataset)\nplt = penguin_bill * datalayer\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n![](index_files/figure-html/cell-31-output-1.svg){}\n:::\n:::\n\n\n여기에 모델의 pdf를 곂치면 아래와 같습니다.\n\n::: {.cell execution_count=31}\n``` {.julia .cell-code}\npdflayer = density() * visual(Contour) * mapping(group = :species, color=:species)\nlayers = pdflayer + datalayer\nplt = penguin_bill * layers\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n![](index_files/figure-html/cell-32-output-1.svg){}\n:::\n:::\n\n\n단색으로 해당되는 확률만 표현할 수도 있습니다.\n\n::: {.cell execution_count=32}\n``` {.julia .cell-code}\npdflayer = density() * visual(Contour, colormap=Reverse(:grays)) * mapping(group = :species, row=:species, col = dataset)\nlayers = pdflayer + datalayer\nplt = penguin_bill * layers\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n![](index_files/figure-html/cell-33-output-1.svg){}\n:::\n:::\n\n\n전체를 같이 표현할 수도 있습니다. \n\n::: {.cell execution_count=33}\n``` {.julia .cell-code}\npdflayer = density() * visual(Contour, colormap=Reverse(:grays)) * mapping(group = :species)\nlayers = pdflayer + datalayer\nplt = penguin_bill * layers\ndraw(plt; axis = axis)\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n![](index_files/figure-html/cell-34-output-1.svg){}\n:::\n:::\n\n\n## 마무리\n\n여러가지 그래프를 손쉽게 결합 생성할 수 있어 전처리가 끝난 자료의 EDA를 진행할 때 굉장히 효과적으로 사용할 수 있을 것으로 판단됩니다.\n또한 몇가지 규칙을 바탕으로 유연하게 확장 가능한 점도 아주 유용한 부분이라고 생각됩니다.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}